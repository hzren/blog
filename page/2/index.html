<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

 


  
  <meta name="description" content=" 程序必须正确。 程序必须可维护，但不能违反第一条定律。 程序必须高效，但不能违反前两条定律。 ">
  <meta name="author" content="renhongzhen"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Code Mark",
    
    "url": "https:\/\/hzren.github.io\/blog\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/hzren.github.io\/blog\/"
  
  
  
  
}
</script>

<meta property="og:title" content="Code Mark" />
<meta property="og:description" content=" 程序必须正确。 程序必须可维护，但不能违反第一条定律。 程序必须高效，但不能违反前两条定律。 ">
<meta property="og:image" content="https://hzren.github.io/blog/img/avatar-icon.png" />
<meta property="og:url" content="https://hzren.github.io/blog/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Code Mark" />

  <meta name="twitter:title" content="Code Mark" />
  <meta name="twitter:description" content=" 程序必须正确。 程序必须可维护，但不能违反第一条定律。 程序必须高效，但不能违反前两条定律。 ">
  <meta name="twitter:image" content="https://hzren.github.io/blog/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@username" />
  <meta name="twitter:creator" content="@username" />
  <link href='https://hzren.github.io/blog/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.109.0">
  <link rel="alternate" href="https://hzren.github.io/blog/index.xml" type="application/rss+xml" title="Code Mark"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://hzren.github.io/blog/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://hzren.github.io/blog/css/highlight.min.css" /><link rel="stylesheet" href="https://hzren.github.io/blog/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">切换导航</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://hzren.github.io/blog/">Code Mark</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="文章" href="/blog/">文章</a>
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent">代码</a>
              <div class="navlinks-children">
                
                  <a href="/blog/post/2017-03-07-bigimg-sample">Big Image Sample</a>
                
                  <a href="/blog/post/2017-03-05-math-sample">Math Sample</a>
                
                  <a href="/blog/post/2016-03-08-code-sample">Code Sample</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="关于我" href="/blog/page/about/">关于我</a>
            </li>
          
        
          
            <li>
              <a title="分类" href="/blog/tags">分类</a>
            </li>
          
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Code Mark" href="https://hzren.github.io/blog/">
            <img class="avatar-img" src="https://hzren.github.io/blog/img/avatar-icon.png" alt="Code Mark" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="page-heading">
              
                <h1>Code Mark</h1>
              
              
                <hr class="small">
              
              
                
                  <span class="page-subheading">软件的设计最终还是要建立在硬件上</span>
                
              
              
            </div>
          </div>
        </div>
      </div>
    </div>
  
  </header>


    
  <div role="main" class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        
          <div class="well">
            <ol>
<li>程序必须正确。</li>
<li>程序必须可维护，但不能违反第一条定律。</li>
<li>程序必须高效，但不能违反前两条定律。</li>
</ol>

          </div>
        

        <div class="posts-list">
          
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-22-java%E8%AF%AD%E8%A8%80/">
        <h2 class="post-title">Java语言</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-22
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;4&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;722&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        引用类型 不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响
强引用（&ldquo;Strong&rdquo; Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。
软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
**弱引用（WeakReference）**并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。
**幻象引用 (PhantomReference)**仅仅是提供了一种确保对象被fnalize以后，做某些事情的机制，比如，通常用来做所谓的Post-Mortem清理机制，我在专栏上一讲中介绍的Java平台自身Cleaner机制等，也有人利用幻象引用监控对象的创建和销毁。
如何工作 这是JDK在语言层面提供的一种可以和GC打交道的机制。如果手动创建ReferenceQueue，一定要对ReferenceQueue里对象就行消非，不然OOM了要。
操过过程：
创建引用对象时需要指定引用队列(ReferenceQueue)。 JVM在调用finalize()方法后，会把对象的引用放入构造器传入的引用队列(ReferenceQueue) 通过判断该引用对象是否入队列来确定对象是否已被垃圾回收(入队时，可能已回收，也可能没回收，当前该对象已不可达) 详细逻辑参照java.lang.ref.Reference文档。
生命周期：
Java定义的不同可达性级别（reachability level），具体如下：
强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。 软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。 弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近fnalize状态的时机，当弱引用被清除的时候，就符合fnalize的条件了。 幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且fnalize过了，只有幻象引用指向这个对象的时候。 不可达（unreachable），意味着对象可以被清除了。判断对象可达性，是JVM垃圾收集器决定如何处理对象的一部分考虑。 引用队列（ReferenceQueue）
JVM会在特定时机将引用enqueue到队列里，我们可以从队列里获取引用（remove方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get方法只返回null，如果再不指定引用队列，基本就没有意义了。看看下面的示例代码。利用引用队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被fnalize了，处于幻象可达状态），执行后期处理逻辑。
字符串 在Java9之前的历史版本中，它是使用char数组来存数据的，这样非常直接。但是Java中的char是两个bytes大小，拉丁语系语言的字符，根本就不需要太宽的char，这样无区别的实现就造成了一定的浪费。
在Java 9中，引入了Compact Strings的设计，对字符串进行了大刀阔斧的改进。将数据存储方式从char数组，改变为一个byte数组加上一个标识编码的所谓coder，并且将相关字符串操作类都进行了修改。另外，所有相关的Intrinsic之类也都进行了重写，以保证没有任何性能损失。虽然底层实现发生了这么大的改变，但是Java字符串的行为并没有任何大的变化，所以这个特性对于绝大部分应用来说是透明的，绝大部分情况不需要修改已有代码。当然，在极端情况下，字符串也出现了一些能力退化，比如最大字符串的大小。
AOP JDK 动态代理，基于接口
cglib 可以基于类，在代理方法执行前后处理一些事情。Spring的cglib方式的事务注解代理，先根据目标类生成代理类并实例化代理对象，把目标对象作为一个属性设置到代理对象上。在需要注入目标类的地方注入代理生成的子类对象。在代码执行过程中：
调用到代理类中重写的代理方法 代理方法内调用到目标类目标方法 目标方法如果调用了自身方法，这时候会出问题，代理类是通过在目标对象上调用目标方法来执行的，并不是通过super.方法名这种形式，所以是调用不到代理方法的。
基本类型 int / integer Java 5中新增了静态工厂方法valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照Javadoc，这个值默认缓存是-128到127之间。
Boolean 在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。
原子更新 AtomicLong 在支持CAS的机器上，通过CAS指令更新，在不支持的机器上，加锁更新。
原子更新通过封装类实现：
AtomicLongFieldUpdater中代码：
/** * Creates and returns an updater for objects with the given field.
        <a href="https://hzren.github.io/blog/blog/2021-01-22-java%E8%AF%AD%E8%A8%80/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/java/">Java</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/jls/">JLS</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-19-linux%E7%BD%91%E7%BB%9C/">
        <h2 class="post-title">Linux网络</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-19
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;8&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1611&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        摘自 倪朋飞-极客时间-Linux性能优化实战
Linux 通用 IP 网络栈的示意图：
网卡是发送和接收网络包的基本设备。在系统启动过程中，网卡通过内核中的网卡驱动程序注册到系统中。而在网络收发过程中，内核通过中断跟网卡进行交互。再结合前面提到的 Linux 网络栈，可以看出，网络包的处理非常复杂。所以，网卡硬中断只处理最核心的网卡数据读取或发送，而协议栈中的大部分逻辑，都会放到软中断中处理。
网络包的接收流程 当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；然后通过硬中断，告诉中断处理程序已经收到了网络包。
接着，网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到sk_buff 缓冲区中；然后再通过软中断，通知内核收到了新的网络帧。
接下来，内核协议栈从缓冲区中取出网络帧，并通过网络协议栈，从下到上逐层处理这个网络帧。比如:
在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。传输层取出 TCP 头或者 UDP 头后，根据 &lt; 源 IP、源端口、目的 IP、目的端口 &gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。
最后，应用程序就可以使用 Socket 接口，读取到新接收到的数据了。
网络包的发送流程 网络包的发送流程就是上图的右半部分，很容易发现，网络包的发送方向，正好跟接收方向相反。
首先，应用程序调用 Socket API（比如 sendmsg）发送网络包。在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。
当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。传输层取出 TCP 头或者 UDP 头后，根据 &lt; 源 IP、源端口、目的 IP、目的端口 &gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。
        <a href="https://hzren.github.io/blog/blog/2021-01-19-linux%E7%BD%91%E7%BB%9C/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/linux/">Linux</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/network/">Network</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-15-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
        <h2 class="post-title">文件系统</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-15
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;5&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1036&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        摘自 倪朋飞-极客时间-Linux性能优化实战
磁盘为系统提供了最基本的持久化存储。文件系统则在磁盘的基础上，提供了一个用来管理文件的树状结构。
索引节点和目录项 文件系统，本身是对存储设备上的文件，进行组织管理的机制。组织方式不同，就会形成不同的文件系统。你要记住最重要的一点，在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。为了方便管理，Linux 文件系统为每个文件都分配两个数据结构，索引节点（indexnode）和目录项（directory entry）。它们主要用来记录文件的元信息和目录结构。
索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。
目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。
磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。
目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。在前面的Buffer 和 Cache 原理中，我曾经提到过，为了协调慢速磁盘与快速 CPU 的性能差异，文件内容会缓存到页缓存 Cache 中。磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中：
超级块，存储整个文件系统的状态。 索引节点区，用来存储索引节点。 数据块区，则用来存储文件数据。 虚拟文件系统 为了支持各种不同的文件系统，Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统 VFS（Virtual File System）。VFS 定义了一组所有文件系统都支持的数据结构和标准接口。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互就可以了，而不需要再关心底层各种文件系统的实现细节。
通过这张图，你可以看到，在 VFS 的下方，Linux 支持各种各样的文件系统，如 Ext4、XFS、NFS 等等。按照存储位置的不同，这些文件系统可以分为三类。
第一类是基于磁盘的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。常见的 Ext4、XFS、OverlayFS 等，都是这类文件系统。 第二类是基于内存的文件系统，也就是我们常说的虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。我们经常用到的 /proc 文件系统，其实就是一种最常见的虚拟文件系统。此外，/sys 文件系统也属于这一类，主要向用户空间导出层次化的内核对象。 第三类是网络文件系统，也就是用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等。 这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录（/），在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys文件系统、NFS 等）挂载进来。
文件系统 I/O 把文件系统挂载到挂载点后，你就能通过挂载点，再去访问它管理的文件了。VFS 提供了一组标准的文件访问接口。这些接口以系统调用的方式，提供给应用程序使用。
容量 用 df 命令，就能查看文件系统的磁盘空间使用情况。比如：
        <a href="https://hzren.github.io/blog/blog/2021-01-15-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/file/">File</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/linux/">Linux</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-15-linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
        <h2 class="post-title">Linux内存管理</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-15
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;2&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;418&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        摘自 倪朋飞-极客时间-Linux性能优化实战
内存映射 物理内存也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。只有内核才可以直接访问物理内存。
Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存。
虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（也就是单个 CPU 指令可以处理数据的最大长度）的处理器，地址空间的范围也不同。
通过这里可以看出，32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间。而 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。
进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存。虽然每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。
既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。
内存映射，其实就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：
页表实际上存储在 CPU 的内存管理单元 MMU 中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。TLB（Translation Lookaside Buffer，转译后备缓冲器）会影响 CPU 的内存访问性能。
TLB 其实就是 MMU 中页表的高速缓存。由于进程的虚拟地址空间是独立的，而 TLB 的访问速度又比 MMU 快得多，所以，通过减少进程的上下文切换，减少 TLB 的刷新次数，就可以提高 TLB 缓存的使用率，进而提高 CPU 的内存访问性能。不过要注意，MMU 并不以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是 4 KB 大小。这样，每一次内存映射，都需要关联 4 KB 或者 4KB整数倍的内存空间。
页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大。比方说，仅 32 位系统就需要 100 多万个页表项（4GB/4KB），才可以实现整个地址空间的映射。
决页表项过多的问题，Linux 提供了两种机制，也就是多级页表和大页（HugePage）。多级页表就是把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保存这些使用中的区块，这样就可以大大地减少页表的项数。
在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：
回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面； 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中； 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。 第二种方式回收不常访问的内存时，会用到交换分区（以下简称 Swap）。Swap其实就是把一块磁盘空间当成内存来用。它可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存时，再从磁盘读取这些数据到内存中（这个过程称为换入）。所以，你可以发现，Swap 把系统的可用内存变大了。不过要注意，通常只在内存不足时，才会发生 Swap 交换。并且由于磁盘读写的速度远比内存慢，Swap 会导致严重的内存性能问题。
        <a href="https://hzren.github.io/blog/blog/2021-01-15-linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/performance/">Performance</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/linux/">Linux</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-15-cpu%E4%BC%98%E5%8C%96/">
        <h2 class="post-title">CPU优化</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-15
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;122&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        摘自 倪朋飞-极客时间-Linux性能优化实战
应用程序优化 首先，从应用程序的角度来说，降低 CPU 使用率的最好方法当然是，排除所有不必要的工作，只保留最核心的逻辑。比如减少循环的层次、减少递归、减少动态内存分配等等。
除此之外，应用程序的性能优化也包括很多种方法，我在这里列出了最常见的几种，你可以记下来。
从系统的角度来说，优化 CPU 的运行，一方面要充分利用 CPU 缓存的本地性，加速缓存访问；另一方面，就是要控制进程的 CPU 使用情况，减少进程间的相互影响。具体来说，系统层面的 CPU 优化方法也有不少，这里我同样列举了最常见的一些方法，方便你记忆和使用。
编译器优化：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。 算法优化：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用 O(nlogn) 的排序算法（如快排、归并排序等），代替 O(n^2) 的排序算法（如冒泡、插入排序等）。 异步处理：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。 多线程代替多进程：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。 善用缓存：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。 系统优化 从系统的角度来说，优化 CPU 的运行，一方面要充分利用 CPU 缓存的本地性，加速缓存访问；另一方面，就是要控制进程的 CPU 使用情况，减少进程间的相互影响。具体来说，系统层面的 CPU 优化方法也有不少，这里我同样列举了最常见的一些方法，方便你记忆和使用。
具体来说，系统层面的 CPU 优化方法也有不少，这里我同样列举了最常见的一些方法，方便你记忆和使用。
CPU 绑定：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨CPU 调度带来的上下文切换问题。 CPU 独占：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些CPU。 优先级调整：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。优先级的数值含义前面我们提到过，忘了的话及时复习一下。在这里，适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理。为进程设置资源限制：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。 NUMA（Non-Uniform Memory Access）优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。 中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。 常见的内核线程### kswapd0：用于内存回收。在 Swap 变高 案例中，我曾介绍过它的工作原理。 kworker：用于执行内核工作队列，分为绑定 CPU （名称格式为 kworker/CPU:ID）和未绑定 CPU（名称格式为 kworker/uPOOL:ID）两类。 migration：在负载均衡过程中，把进程迁移到 CPU 上。每个 CPU 都有一个 migration 内核线程。 jbd2/sda1-8：jbd 是 Journaling Block Device 的缩写，用来为文件系统提供日志功能，以保证数据的完整性；名称中的 sda1-8，表示磁盘分区名称和设备号。每个使用了 ext4 文件系统的磁盘分区，都会有一个 jbd2 内核线程。 pdflush：用于将内存中的脏页（被修改过，但还未写入磁盘的文件页）写入磁盘（已经在3.
        <a href="https://hzren.github.io/blog/blog/2021-01-15-cpu%E4%BC%98%E5%8C%96/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/performance/">Performance</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-15-%E4%B8%AD%E6%96%AD/">
        <h2 class="post-title">中断</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-15
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;2&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;223&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        摘自 倪朋飞-极客时间-Linux性能优化实战
中断是一种异步的事件处理机制，可以提高系统的并发处理能力。
由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。如果中断本身要做的事情不多，那么处理起来也不 会有太大问题；但如果中断要处理的事情很多，中断服务程序就有可能要运行很长时间。
特别是，中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。
软中断 为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：
上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。 下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。 以最常见的网卡接收数据包为例：
网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。你可以自己先想一下，这种情况下的上半部和下半部分别负责什么工作呢？
对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。 而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。 所以，这两个阶段你也可以这样理解：
上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行； 而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。 实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。
不过要注意的是，软中断不只包括了刚刚所讲的硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和 RCU 锁（Read-Copy Update 的缩写，RCU 是 Linux 内核中最常用的锁之一）等。
查看软中断和内核线程 不知道你还记不记得，前面提到过的 proc 文件系统。它是一种内核空间和用户空间进行通信的机制，可以用来查看内核的数据结构，或者用来动态修改内核的配置。其中：
/proc/softirqs 提供了软中断的运行情况 /proc/interrupts 提供了硬中断的运行情况 运行下面的命令，查看 /proc/softirqs 文件的内容，你就可以看到各种类型软中断在不同CPU 上的累积运行次数：
[root@testswarm1 ~]# cat /proc/softirqs CPU0 CPU1 CPU2 CPU3 HI: 0 0 0 0 TIMER: 12631619 232062373 248462702 893005335 NET_TX: 8896509 4597175 4634277 4587284 NET_RX: 2318866690 2162127770 2156810551 2166304170 BLOCK: 122868813 128777565 140769264 127375707 IRQ_POLL: 0 0 0 0 TASKLET: 4994443 830265 910880 1602220 SCHED: 1556077017 1449705571 1371002788 1403110449 HRTIMER: 14076 12295 11558 14612 RCU: 3175872103 3298281937 3300542031 38936799 在查看 /proc/softirqs 文件内容时，你要特别注意以下这两点。
        <a href="https://hzren.github.io/blog/blog/2021-01-15-%E4%B8%AD%E6%96%AD/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/performance/">Performance</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/linux/">Linux</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-14-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">
        <h2 class="post-title">上下文切换</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-14
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;116&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        摘自 倪朋飞-极客时间-Linux性能优化实战
在Linux系统中，对于用户创建的进程(线程)来说，CPU分配时间片的单位是线程还是进程?
是线程。线程是实际工作的单元[1]，进程只是一个容器，用来管理一个或多个线程。
这是不是就意味着尽量使用多线程并发，这样可以抢到更多的时间片?
以下摘自Linux性能优化实战
理论上是的，多线程的一种用途就是能同时做好几件事情，以提高效率。但实际问题是，CPU的数量（核心数，下同）是有限的，而且并不多。如果你的CPU有8个CPU，并且整个系统中有8个线程的话，不考虑中断等因素，每个线程理论上能一直执行下去。然而多于8个线程以后，操作系统就必须进行调度，也就是分配时间片。
而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）。
CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。
知道了什么是 CPU 上下文，我想你也很容易理解 CPU 上下文切换。CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。
而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。
根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。
进程上下文切换 Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中，CPU 特权等级的 Ring 0 和 Ring 3。
内核空间（Ring 0）具有最高权限，可以直接访问所有资源； 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。 换个角度看，也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。
那么，系统调用的过程有没有发生 CPU 上下文的切换呢？答案自然是肯定的。
CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码， CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。
不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：进程上下文切换，是指从一个进程切换到另一个进程运行。而系统调用过程中一直是同一个进程在运行。
所以，系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。
        <a href="https://hzren.github.io/blog/blog/2021-01-14-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/linux/">Linux</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-13-%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE/">
        <h2 class="post-title">路由条目</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-13
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;3&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;628&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        ip route命令的输出解释。
获取工具 ip命令包含在net-tools包中，可以通过安装net-tools包获得该命令。
常见用法 执行man ip route
IP-ROUTE(8) Linux IP-ROUTE(8) NAME ip-route - routing table management SYNOPSIS ip [ ip-OPTIONS ] route { COMMAND | help } ip route { list | flush } SELECTOR ip route save SELECTOR ip route restore ip route get ADDRESS [ from ADDRESS iif STRING ] [ oif STRING ] [ tos TOS ] ip route { add | del | change | append | replace } ROUTE SELECTOR := [ root PREFIX ] [ match PREFIX ] [ exact PREFIX ] [ table TABLE_ID ] [ proto RTPROTO ] [ type TYPE ] [ scope SCOPE ] ROUTE := NODE_SPEC [ INFO_SPEC ] NODE_SPEC := [ TYPE ] PREFIX [ tos TOS ] [ table TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ] [ metric METRIC ] INFO_SPEC := NH OPTIONS FLAGS [ nexthop NH ] .
        <a href="https://hzren.github.io/blog/blog/2021-01-13-%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/network/">Network</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-12-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/">
        <h2 class="post-title">容器网络</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-12
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;203&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        容器网络的核心是和物理网络实现网络隔离，物理网络对于容器来说为虚拟的，不可见的。
概念 Overlay / 覆盖网络
覆盖网络（Overlay network）是一种建立在另一网络之上的计算机网络。
覆盖网络中的节点可以被认为是通过虚拟或逻辑链接相连，其中每个链接对应一条路径（Path）。节点之间也可能通过下层网络中的多个物理连接实现相连。
Flannel Flannel有UDP和VXLAN两种方案
使用UDP实现Overlay网络 Flannel的覆盖网络：Flannel另创建了一个网络100.96.0.0/16，它是一个更大的网络，可以容纳2个¹⁶（65536）地址，它覆盖所有kubernetes节点，每个pod将在这个范围内分配一个地址。
在主机docker网络中：在每个主机中，flannel为该主机中的所有pod分配了一个100.96.x.0/24网络，它可以容纳2⁸（256）个地址。docker网桥docker0将使用此网络创建新容器。
通过这种设计，每个容器都有自己的IP地址，都属于覆盖子网100.96.0.0/16。同一主机内的容器可以通过docker网桥docker0相互通信。
为了在主机间与覆盖网络中的其他容器进行通信，flannel使用内核路由表和UDP封装来实现它，下面几节将对此进行解释。
发包过程 假设节点1中IP地址为100.96.1.2的容器（我们称之为container-1）想要连接到节点2中IP地址为100.96.2.3的容器（我们称之为container-2）:
第一个container-1创建一个src:100.96.1.2-&gt;dst:100.96.2.3的IP数据包，该数据包将直接被发送到容器的网关-docker0网桥。
在每个主机中，flannel会运行一个名为flanneld的守护进程，flanneld会在内核的路由表中创建一些路由规则，节点1的路由表一般是这样的：
admin@ip-172-20-33-102:~$ ip route default via 172.20.32.1 dev eth0 100.96.0.0/16 dev flannel0 proto kernel scope link src 100.96.1.0 100.96.1.0/24 dev docker0 proto kernel scope link src 100.96.1.1 172.20.32.0/19 dev eth0 proto kernel scope link src 172.20.33.102 如上所见，包的目的地址100.96.2.3落在更大的覆盖网络100.96.0.0/16中，因此它符合第二条规则100.96.0.0/16 dev flannel0 proto kernel scope link src 100.96.1.0，现在根据路由规则内核把包发送到flannel0虚拟网卡。
100.96.0.0/16 dev flannel0 proto kernel scope link src 100.
        <a href="https://hzren.github.io/blog/blog/2021-01-12-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/network/">Network</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/docker/">Docker</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2021-01-06-%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E5%88%B0%E5%85%AC%E7%BD%91_%E5%85%AC%E7%BD%91%E5%AF%BC%E5%86%85%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E8%BF%87%E7%A8%8B/">
        <h2 class="post-title">一次内网到公网_公网导内网的数据链路过程</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2021-01-06
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;69&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <blockquote>
<p>以一次从内网到公网，公网到内网的数据交互过程来梳理整个网络链路。</p>
</blockquote>
<h2 id="网络拓扑图">网络拓扑图</h2>
<p><img src="/static/attachment/20210111/20210111-1.png" alt="网络拓扑图"></p>
<blockquote>
<p>MAC地址是一个局域网内才有效的地址。因而，MAC地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于IP地址是否改变。<strong>不改变IP地址的网关，我们称为转发网关；改变IP地址的网关，我们称为NAT网关。</strong></p>
</blockquote>
<p>每到一个新的局域网，MAC都是要变的，但是IP地址都不变。在IP头里面，不会保存任何网关的IP地址。<strong>所谓的下一跳是，某个IP要将这个IP地址转换为MAC放入MAC头</strong></p>
<p>上图中：
<strong>手机A1， A2, 交换机A，路由器A组成了用户的小内网，以NAT的方式访问外网</strong>。
<strong>BGP网关ABCD组成了外网互联，根据IP地址转发路由</strong></p>
<h2 id="请求出内网">请求出内网</h2>
<ol>
<li>手机A1需要向服务器B1发送数据， 手机A1发现B1和其不在同一网段
a. 手机A1在内网内广播获取网关(路由器A)IP的ARP请求
b. 网关(路由器A)收到ARP请求后，以单播的形式向手机A1发送ARP响应，返回其MAC地址
c. 内网中其他设备收到ARP请求后发现不是寻找本设备忽略该数据包</li>
<li>手机A1拿到网关(路由器A)MAC地址后，封装二层数据包；目标MAC地址是网关MAC，三层数据包里面的目的IP是服务器B1的公网IP</li>
<li>交换机A1在收到手机A1发来的数据包后，根据从端口学习到的MAC地址映射将数据包从响应端口法网路由器A</li>
<li>路由器A收到数据报文后，对比MAC数据报文中的MAC地址
a. 不是发往自己的，丢弃
b. 是发往自己的，检查三层数据包IP地址</li>
</ol>
<h2 id="请求在公网">请求在公网</h2>
<ol>
<li>
<p>路由器A根据三层目标IP地址和自身的公网路由规则，得到下一跳网关（BGP网关B）IP地址，然后根据ARP获得的下一条网关MAC地址，重组数据包：</p>
<ul>
<li>源IP替换为自身公网IP</li>
<li>对于TCP，UDP数据，修改三层数据包端口，建立NAT映射，所有来自该内网IP+端口的数据都会经公网IP+一固定端口转发；公网IP上该固定端口收到的数据都会被转发到对应内网IP+端口上</li>
<li>源MAC地址替换为自身公网网卡MAC</li>
<li>目标IP不变</li>
<li>目标IP替换为下一跳网关MAC地址</li>
</ul>
</li>
<li>
<p>BGP网关B收到数据包后判断目标IP是否在本网关所对应的子网中，发现不在，继续转发数据包至BGP网关D，转发过程如下：</p>
<ul>
<li>源IP不变</li>
<li>源MAC地址替换为自身公网网卡MAC</li>
<li>目标IP不变</li>
<li>目标IP替换为下一跳网关MAC地址</li>
</ul>
</li>
<li>
<p>BGP网关发现目标IP在本网关所对应的子网中，对数据包进行转发到服务器B1</p>
</li>
<li>
<p>服务器B1收到数据包后，检查目标MAC地址，确认是自己的，收包，否则丢弃</p>
</li>
</ol>
<h2 id="响应在公网">响应在公网</h2>
<ol>
<li>服务器B返回数据包
<ul>
<li>目标IP：路由器A公网出口IP</li>
<li>目标MAC ： 路由器A公网出口MAC</li>
<li>源IP ： 自身公网IP</li>
<li>源MAC : 自身公网MAC</li>
</ul>
</li>
</ol>
<p>过程同<strong>请求在公网</strong></p>
<blockquote>
<p>IP报文的请求路径和响应路径很可能是不同的，具体须经由网关路由规则确定。</p>
</blockquote>
<h2 id="响应在客户端内网">响应在客户端内网</h2>
<p>路由器A公网网口收到响应数据包，在确定目标MAC地址是自身后， 根据路由/转发规则和三层数据包里面的链接标识确定数据包最终转发到那台内网机器。</p>
<h3 id="tcpudp请求">TCP/UDP请求</h3>
<ol>
<li>根据NAT映射关系，修改数据包数据
<ul>
<li>修改三层数据包目的IP为映射的内网机器IP</li>
<li>修改三层数据包目的端口为映射IP的映射端口</li>
<li>修改</li>
</ul>
</li>
<li>转发修改后的数据包到固定内网IP和端口上。</li>
</ol>
<h3 id="icmp">ICMP</h3>
<p>ICMP协议无端口，根据三层数据包里面的ICMP Query ID确定内网IP。</p>
<p><img src="/static/attachment/20210111/20210111-2.png" alt="网络拓扑图"></p>
<p>原文见： <a href="https://tools.ietf.org/html/draft-srisuresh-behave-nat-icmp-02">IETF文档</a> 3.1章节</p>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/network/">Network</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/nat/">NAT</a>&nbsp;
        
    </div>
    

</article>
          
        </div>

        
          <ul class="pager main-pager">
            
              <li class="previous">
                <a href="https://hzren.github.io/blog/page/1/">&larr; 上一页</a>
              </li>
            
            
              <li class="next">
                <a href="https://hzren.github.io/blog/page/3/">下一页 &rarr;</a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>

      
    <div class="page-meta">
  
  
  
</div>


  
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
		
		  <a href="mailto:hzren@outlook.com" title="Email me">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.facebook.com/username" title="Facebook">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://github.com/username" title="GitHub">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://gitlab.com/username" title="GitLab">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-gitlab fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://bitbucket.org/username" title="Bitbucket">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-bitbucket fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://twitter.com/username" title="Twitter">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://username.slack.com/" title="Slack">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-slack fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://reddit.com/u/username" title="Reddit">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-reddit-alien fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://linkedin.com/in/username" title="LinkedIn">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.xing.com/profile/username" title="Xing">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-xing fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://stackoverflow.com/users/XXXXXXX/username" title="StackOverflow">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.snapchat.com/add/username" title="Snapchat">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-snapchat-ghost fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.instagram.com/username" title="Instagram">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-instagram fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.youtube.com/user/username" title="Youtube">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-youtube fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://soundcloud.com/username" title="SoundCloud">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-soundcloud fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://open.spotify.com/user/username" title="Spotify">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-spotify fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://username.bandcamp.com/" title="Bandcamp">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-bandcamp fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://itch.io/profile/username" title="Itch.io">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-gamepad fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://vk.com/username" title="VK">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-vk fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://paypal.me/username" title="PayPal">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-paypal fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://telegram.me/username" title="Telegram">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-telegram fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://500px.com/username" title="500px">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-500px fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://codepen.io/username" title="CodePen">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-codepen fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.kaggle.com/username" title="kaggle">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-kaggle fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a rel="me"href="https://url" title="Mastodon">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-mastodon fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://weibo.com/username" title="Weibo">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-weibo fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://discord.gg/invite%20code%20%28https://discord.gg/XXXXXXX%29" title="Discord">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-discord fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.strava.com/athletes/userid" title="Strava">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-strava fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="/blog/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://hzren.github.io/blog/">renhongzhen</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2022
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://hzren.github.io/blog/">Code Mark</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          由 <a href="https://gohugo.io">Hugo v0.109.0</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> 移植自 <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://hzren.github.io/blog/js/main.js"></script>
<script src="https://hzren.github.io/blog/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://hzren.github.io/blog/js/load-photoswipe.js"></script>









    
  </body>
</html>

