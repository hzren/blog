<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

 


  
  <meta name="description" content=" 程序必须正确。 程序必须可维护，但不能违反第一条定律。 程序必须高效，但不能违反前两条定律。 ">
  <meta name="author" content="renhongzhen"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Code Mark",
    
    "url": "https:\/\/hzren.github.io\/blog\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/hzren.github.io\/blog\/"
  
  
  
  
}
</script>

<meta property="og:title" content="Code Mark" />
<meta property="og:description" content=" 程序必须正确。 程序必须可维护，但不能违反第一条定律。 程序必须高效，但不能违反前两条定律。 ">
<meta property="og:image" content="https://hzren.github.io/blog/img/avatar-icon.png" />
<meta property="og:url" content="https://hzren.github.io/blog/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Code Mark" />

  <meta name="twitter:title" content="Code Mark" />
  <meta name="twitter:description" content=" 程序必须正确。 程序必须可维护，但不能违反第一条定律。 程序必须高效，但不能违反前两条定律。 ">
  <meta name="twitter:image" content="https://hzren.github.io/blog/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@username" />
  <meta name="twitter:creator" content="@username" />
  <link href='https://hzren.github.io/blog/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.109.0">
  <link rel="alternate" href="https://hzren.github.io/blog/index.xml" type="application/rss+xml" title="Code Mark"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://hzren.github.io/blog/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://hzren.github.io/blog/css/highlight.min.css" /><link rel="stylesheet" href="https://hzren.github.io/blog/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">切换导航</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://hzren.github.io/blog/">Code Mark</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="文章" href="/blog/">文章</a>
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent">代码</a>
              <div class="navlinks-children">
                
                  <a href="/blog/post/2017-03-07-bigimg-sample">Big Image Sample</a>
                
                  <a href="/blog/post/2017-03-05-math-sample">Math Sample</a>
                
                  <a href="/blog/post/2016-03-08-code-sample">Code Sample</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="关于我" href="/blog/page/about/">关于我</a>
            </li>
          
        
          
            <li>
              <a title="分类" href="/blog/tags">分类</a>
            </li>
          
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Code Mark" href="https://hzren.github.io/blog/">
            <img class="avatar-img" src="https://hzren.github.io/blog/img/avatar-icon.png" alt="Code Mark" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="page-heading">
              
                <h1>Code Mark</h1>
              
              
                <hr class="small">
              
              
                
                  <span class="page-subheading">软件的设计最终还是要建立在硬件上</span>
                
              
              
            </div>
          </div>
        </div>
      </div>
    </div>
  
  </header>


    
  <div role="main" class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        
          <div class="well">
            <ol>
<li>程序必须正确。</li>
<li>程序必须可维护，但不能违反第一条定律。</li>
<li>程序必须高效，但不能违反前两条定律。</li>
</ol>

          </div>
        

        <div class="posts-list">
          
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-08-06-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%8F%8A%E5%8A%9F%E8%83%BD/">
        <h2 class="post-title">计算机网络中常见中间设备名称及功能</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-08-06
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;58&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h3 id="集线器hub">集线器/HUB:</h3>
<p>集线器（Ethernet hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的装置。集线器是运作在OSI模型中的实体层，可以让其连结的设备工作在同一网段。集线器上有多个I/O端口，信号从任意一个端口进入后，会从其他端口出现。中继器（Repeater hub，集线器的一种）也会参与冲突检测（collision detection），在检测到冲突时向所有端口转发拥塞信号。</p>
<p>集线器相比于交换机更为简单，它可以被视作有多个端口的中继器，从一个端口接受比特位（或符号），再从其他端口送出。它对物理层数据包有所感知，可以检测到其开始、挂起及冲突。在检测到冲突时会发送拥塞信号以传播这一事件。集线器不能对经过它的网络流量做更进一步地检查与管理：任何进入的数据包都会被广播到其他端口。集线器/中继器无法储存数据——数据包必须在接收时被发送，一旦发生冲突，就会丢包（发送端应当能够侦测到，并重新发送）。基于此，集线器只能以半双工模式工作。因此，由于冲突域更广，相比于使用更复杂的网络设备，使用集线器的数据网络更容易出现数据包冲突。</p>
<p>以太网设计目标：电脑使用一个网络接口，可以同时与多台电脑通信，将电脑连接起来的黑盒子最先面世，称之为集线器，但我们更喜欢叫它Hub。
这种集线器，通常有多个端口，可以接入多台电脑，这种黑盒子使电脑连接在一起成为一种可能，<strong>其内部工作原理，就是信号放大器</strong>。</p>
<blockquote>
<p><strong>HUB内部采用广播的形式传播其收到的每一个网络包.因为其采用广播的形式, 这就注定了一个HUB上不可能有太多端口, 不能链接太多电脑, 不然在广播网络时就形成了网络风暴。</strong></p>
</blockquote>
<p><strong>由于HUB只是简单的转发，所以hub工作在物理层（L1）。</strong></p>
<p><img src="/static/attachment/20200806/d46ffd1576374f0780956364f579b31a.jpg" alt=""></p>
<h3 id="网桥">网桥:</h3>
<p>网桥将网络的多个网段在数据链路层（OSI模型第2层）连接起来（即桥接）。</p>
<p>网桥有别于路由器。路由器允许多个网络之间的独立通信，但又保持区隔，而网桥则是将两个独立的网络连接起来，就如同单一网络。如果所桥接的网络有一个以上的区段是无线网络，则该设备称为无线网桥。</p>
<p>桥接器在功能上与集线器等其他用于连接网段的设备类似，不过后者工作在物理层（OSI模型第1层）。</p>
<ol>
<li>
<p>网桥能够识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的数据帧转发给相连的另一个网段（network segment）。由于能够对数据帧拆包、暂存、重新打包（称为存储转发机制store-and-forward），网桥能够连接不同技术参数传输速率的数据链路，如连接10BASE-T与100BASE-TX。</p>
</li>
<li>
<p>数据帧中有一个位叫做FCS，用来通过CRC方式校验数据帧中的位。网桥可以检查FCS，将那些损坏的数据帧丢弃。</p>
</li>
<li>
<p>网桥在向其他网段转发数据帧时会做冲突检测控制。</p>
</li>
<li>
<p>网桥还能通过地址自学机制和过滤功能控制网络流量，具有OSI第2层网络交换机功能。其机制是网桥内部有一个数据库，最初没有数据。当网桥从一个网段收到一个数据帧，就会在数据库中登记（或者更新）数据帧的源地址属于这个网段，并检查数据包的目的地址。如果目的地址在数据库中属于另外一个网段，则网桥向该网段转发该数据帧；如果目的地址在数据库中没有记录，则网桥向除了源地址所在之外的其他所有网段转发（flood）该数据帧。</p>
</li>
<li>
<p>桥接器仅仅在不同网络之间有数据传输的时候才将数据转发到其他网络，不是像集线器那样对所有数据都进行广播。对于以太网，“桥接”这一术语正式的含义是指符合IEEE802.1D标准的设备，即“网络切换”。网桥可以分割网段，不似集线器仍是在为同一碰撞域，所以对频宽耗损较大。因网桥透过其内之MAC表格，让传送帧不会通过，所以其称之为数据连接层操作之网络元件，可隔离碰撞。</p>
</li>
</ol>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3932586909,2508499189&amp;fm=26&amp;gp=0.jpg" alt=""></p>
<h3 id="交换机">交换机:</h3>
<p>在集线器的基础上，添加了MAC地址学习功能，成为了交换机，这样可以避免集线器对所有帧都广播的弊病。</p>
<p>交换机是一种多端口的网桥，在数据链路层使用MAC地址转发数据。通过引入路由功能，一些交换机也可以在网络层转发数据，这种交换机一般被称为三层交换机或者多层交换机。</p>
<h4 id="工作原理">工作原理</h4>
<p>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p>
<p>交换机对数据包的转发是建立在MAC地址——物理地址基础之上的，对于IP网络协议来说，它是透明的，即交换机在转发数据包时，不知道也无须知道信源机和信宿机的IP地址，只需知其物理地址。</p>
<p>交换机在操作过程当中会不断的收集资料去建立它本身的一个地址表，这个表相当简单，它说明了某个MAC地址是在哪个端口上被发现的，所以当交换机收到一个TCP/ IP封包时，它便会查看该数据包的目的MAC地址，核对自己的地址表以确认应该从哪个端口把数据包发出去。由于这个过程比较简单，加上这功能由一崭新硬件进行——ASIC，因此速度相当快。一般只需几十微秒，交换机便可决定一个IP封包该往哪里送。</p>
<p>如果目的地MAC地址不能在地址表中找到时，交换机会把IP封包「扩散」出去，即把它从每一个端口中送出去，就如交换机在处理一个收到的广播封包时一样。二层交换机的弱点正是它处理广播封包的手法不太有效，比方说，当一个交换机收到一个从TCP / IP工作站上发出来的广播封包时，他便会把该封包传到所有其他端口去，哪怕有些端口上连的是IPX或DECnet工作站。这样一来，非TCP/ IP节点的带宽便会受到负面的影响，就算同样的TCP/ IP节点，如果他们的子网跟发送那个广播封包的工作站的子网相同，那幺他们也会无缘无故地收到一些与他们毫不相干的网络广播，整个网络的效率因此会大打折扣。</p>
<h4 id="工作方式">工作方式</h4>
<p>当一台交换机安装配置好之后，其工作过程如下：</p>
<ul>
<li>收到某网段（设为A）MAC地址为X的计算机发给MAC地址为Y的计算机的数据包。交换机从而记* 下了MAC地址X在网段A。这称为学习（learning）。</li>
<li>交换机还不知道MAC地址Y在哪个网段上，于是向除了A以外的所有网段转发该数据包。这称为泛洪（flooding）。</li>
<li>MAC地址Y的计算机收到该数据包，向MAC地址X发出确认包。交换机收到该包后，从而记录下MAC地址Y所在的网段。</li>
<li>交换机向MAC地址X转发确认包。这称为转发（forwarding）。</li>
<li>交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包。这称为过滤（filtering）。</li>
<li>交换机内部的MAC地址-网段查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。</li>
<li>对于全交换（full-switch）局域网，交换机每个端口只连接一台设备，因此不会发生碰撞。交换机也不需要做过滤。</li>
</ul>
<p><strong>但这些设备依然都是桥接设备，因为帧经过它们时，帧原封不动。</strong></p>
<p>但是随着无线局域网的诞生，关于桥接的定义被刷新，有线的Ethernet II 帧访问无线802.11时，帧格式发生了变化，但依然称AP（Access Point)为桥接设备，为何？因为一个广播帧可以无障碍通过AP，AP并没有分割广播域，所以依然是桥接设备。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1596715477673&amp;di=8224c33785f9645c722a8f5d44f0a52b&amp;imgtype=0&amp;src=http%3A%2F%2Ftgi13.jia.com%2F115%2F804%2F15804177.gif" alt=""></p>
<h3 id="路由器">路由器</h3>
<blockquote>
<p>路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定封包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的封包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）</p>
</blockquote>
<h4 id="基本概念">基本概念</h4>
<p>由器就是连接两个以上个别网络的设备。</p>
<p>由于位于两个或更多个网络的交汇处，从而可在它们之间传递分组（一种数据的组织形式）。路由器与交换机在概念上有一定重叠但也有不同：交换机泛指工作于任何网络层次的数据中继设备（尽管多指网桥），而路由器则更专注于网络层。</p>
<p>路由器与交换机的差别，路由器是属于OSI第三层的产品，交换机是OSI第二层的产品。第二层的产品功能在于，将网络上各个电脑的MAC位址记在MAC地址表中，当区域网路中的电脑要经过交换机去交换传递数据时，就查询交换机上的MAC地址表中的信息，将封包传送给指定的电脑，而不会像第一层的产品（如集线器）每台在网络中的电脑都发送。而路由器除了有交换机的功能外，更拥有路由表作为传送封包时的依据，在有多种选择的路径中选择最佳的路径。此外，并可以连接两个以上不同网段的网络，而交换机只能连接两个。并具有IP分享的功能，如：区分哪些封包是要传送至WAN。路由表存储了（向前往）某一网络的最佳路径，该路径的“路由度量值”以及下一个（跳路由器）。参考条目路由获得这个过程的详细描述。</p>
<p>尽管也有其它一些很少用到的被路由协议，但路由通常指的就是IP路由。</p>
<p><img src="https://tenfei01.cfp.cn/creative/vcg/veer/800water/veer-328513495.jpg" alt=""></p>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/network/">Network</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-08-06-redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81/">
        <h2 class="post-title">Redis哨兵模式概要</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-08-06
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;2&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;288&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        哨兵模式的官方说明 Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务： . 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 . 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。 . 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。
获取 Sentinel 现在Sentinel就包含在redis发行版中，sentinel是redis发行版的一部分。
启动 Sentinel 对于 redis-sentinel 程序， 可以用以下命令来启动 Sentinel 系统：
redis-sentinel /path/to/sentinel.conf 对于 redis-server 程序， 你可以用以下命令来启动一个运行在 Sentinel 模式下的 Redis 服务器：
redis-server /path/to/sentinel.conf --sentinel 两种方法都可以启动一个 Sentinel 实例。 启动 Sentinel 实例必须指定相应的配置文件， 系统会使用配置文件来保存 Sentinel 的当前状态， 并在 Sentinel 重启时通过载入配置文件来进行状态还原。 如果启动 Sentinel 时没有指定相应的配置文件， 或者指定的配置文件不可写（not writable）， 那么 Sentinel 会拒绝启动。
        <a href="https://hzren.github.io/blog/blog/2020-08-06-redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/redis/">Redis</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-08-04-%E4%B8%80%E6%AC%A1httpheaders-setcontentdispositionformdata-%E5%BC%95%E5%8F%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%93%BE%E6%8E%A5%E5%BC%82%E5%B8%B8%E8%AE%B0%E5%BD%95/">
        <h2 class="post-title">一次HttpHeaders setContentDispositionFormData 引发的服务端链接异常记录</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-08-04
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;69&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <blockquote>
<p>正常情况下，告诉浏览器当前请求的响应是下载一个文件，对应的http header应该是这样的 ：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">HTTP/1.1 200 OK
</span></span><span class="line"><span class="cl">Server: Apache-Coyote/1.1
</span></span><span class="line"><span class="cl">Content-Disposition: attachment;fileName=CMClient.apk
</span></span><span class="line"><span class="cl">Content-Type: application/octet-stream;charset=UTF-8
</span></span><span class="line"><span class="cl">Content-Length: 3501505
</span></span><span class="line"><span class="cl">Date: Wed, 26 Feb 2014 06:06:53 GMT
</span></span></code></pre></div><blockquote>
<p>该头信息的关键就在于这两个字段：</p>
</blockquote>
<ul>
<li><strong>Content-Disposition: attachment;fileName=CMClient.apk</strong></li>
<li><strong>Content-Type: application/octet-stream;charset=UTF-8</strong></li>
</ul>
<p><strong>Content-Disposition: attachment;fileName=CMClient.apk</strong> 告诉浏览器当前的响应是下载文件， 文件以CMClient.apk这个名字进行存储。
<strong>Content-Type: application/octet-stream;charset=UTF-8</strong> 告诉浏览器响应的内容是以流的形式传输。</p>
<blockquote>
<p>在代码实现中，直接调用Spring MVC的HttpHeaders setContentDispositionFormData方法进行设置，在浏览器通过firebug观察实际返回的头信息：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">HTTP/1.1 200 OK
</span></span><span class="line"><span class="cl">Server: Apache-Coyote/1.1
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;attachment&#34;; filename=&#34;CMClient.apk&#34;
</span></span><span class="line"><span class="cl">Content-Type: application/octet-stream;charset=UTF-8
</span></span><span class="line"><span class="cl">Content-Length: 3501505
</span></span><span class="line"><span class="cl">Date: Wed, 26 Feb 2014 06:08:13 GMT
</span></span></code></pre></div><blockquote>
<p>这种做法在PC的上Chrome，Firefox 上表现正常， 在Android 4.03上却出现了问题，server端出现了在流未写完链接就被远程客户端关闭的异常。
调试发现Android浏览器在第一次收到响应后直接关闭了当前链接，新开了一链接下载该文件，所以出现了服务器端链接异常关闭的错误
诡异的问题，服务端改为改为调用 public void add(String headerName, String headerValue)方法手动设置浏览器各个头信息，设置完成后正常。</p>
</blockquote>
<blockquote>
<p><strong>框架层掩盖了太多细节，浏览器表现的不一致性是最大的问题，最好的办法还是按照标准文档手动去设置头信息</strong></p>
</blockquote>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-08-03-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%99%A8url/">
        <h2 class="post-title">统一资源定位器（URL）</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-08-03
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;7&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1352&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        目录
1．绪论... 2
2．常规URL语法... 2
2．1&nbsp; URL的主要部分... 2
2．2&nbsp; URL字符编码问题... 3
2．3 分层方案和关系链接... 4
3．特殊方案... 4
3．1通用因特网方案语法... 4
3．2 FTP. 5
3．3 HTTP. 7
3．4 GOPHER. 7
3．5 MAILTO.. 9
3．6 NEWS（新闻）... 10
3．7 NNTP（Network News Transfer Protocol,网络新闻传输协议）... 10
3．8 TELNET. 10
3．9 WAIS（Wide Area Information Servers,广域信息服务系统）... 11
3．10 FILES(文件) 11
3．11 PROSPERO.. 12
4． 新方案的注册... 13
5．特定URL方案的BNF（巴柯斯范式）... 13
6．安全事项... 16
7．感谢... 16
附录：上下文URL的推荐标准... 17
参考文献：... 17
编者地址：... 19
&nbsp;
        <a href="https://hzren.github.io/blog/blog/2020-08-03-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%99%A8url/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-08-01-%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%93%E5%AD%98%E5%8A%A0%E5%87%8F%E6%80%9D%E8%B7%AF%E6%80%9D%E8%80%83/">
        <h2 class="post-title">电商网站高并发场景下的库存加减思路思考</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-08-01
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;60&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h3 id="前言">前言</h3>
<blockquote>
<p>每当电子商务平台搞活动，“秒杀”经常是提升网站活跃度的利器之一。比如活动日早上10点1元爱疯7秒杀7台，谁看到了估计都想去秒一把，万一秒中了呢。秒杀的典型特征就是在特定的短时间突然涌入大量请求，对系统造成洪峰冲击，如果系统设计得不好，很容易被直接打垮掉。现在因为疫情原因，秒杀场景也变得更泛化，很多时候会出现商品被瞬间抢完的情况，如果时通过数据库直接扣库存的话， 会给数据库带来了很大压力。很有可能整个数据库会HANG在那里，导致整个系统被拖垮。</p>
</blockquote>
<h3 id="问题">问题</h3>
<p><strong>为什么高并发场景下直接数据库扣库存会搞垮整个数据库呢？</strong></p>
<blockquote>
<p><strong>数据库事务特性： 对于一条记录，数据库在该事务修改的时候加锁，在整个事务提交完才释放锁。</strong>
这样就导致一个问题，当同时有多个请求对同一条记录(库存记录)进行修改时，会在该记录上造成锁排队现象，流程大概时这样的：</p>
<ol>
<li>在同一时间点有A，B，C五个数据库线程对记录K进行修改</li>
<li>A开始事务，对K加锁</li>
<li>B开始事务，对K加所，发现K已锁，等待K锁释放</li>
<li>C同上</li>
<li>A释放锁，B(也可能C，视数据库实现而定)获得锁，C继续等待</li>
<li>B释放锁，C获得锁
从上面的整个流程可以看出，在高并发场景下，对K的更新操作变成了线性操作，假设一个事务1ms处理完，当同时有成百上千个修改请求同时过来的时候，后面的修改请求响应时间就大大变长，如果数据库给每个链接分配一个单独的线程来处理，就会导致数据库服务器可用线程急剧下降，当无可用线程时，整个数据库就HANG在了那里。</li>
</ol>
</blockquote>
<h3 id="解决思路">解决思路</h3>
<blockquote>
<p><strong>最好的并发就是没有并发</strong>
我们预先把库存数值缓存到内存中，这个内存可以是业务服务器内存，也可以是专用的缓存服务器，例如redis这种。当有库存操作的时候，我们直接在内存层面进行加减操作，在数据库没有唯一键冲突的情况下，数据库插入操作也比库存修改操作快的多，用这两种当时来实现库存个高并发修改。</p>
</blockquote>
<h4 id="redis扣库存">redis扣库存</h4>
<blockquote>
<p>redis 是一个高兴能的缓存服务器，它提供了很强大的指令功能，它可以对某个缓存的KEY进行值的加减操作，其TPS可以达到10W级别。在redis层面，我们使用lua脚本来进行数据库加减操作。
脚本如下：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">local num = redis.call(&#39;get&#39;, KEYS[1])
</span></span><span class="line"><span class="cl">local minus = tonumber(KEYS[2]);
</span></span><span class="line"><span class="cl">if tonumber(num) &gt; minus then
</span></span><span class="line"><span class="cl">    redis.call(&#39;decr&#39;, minus)
</span></span><span class="line"><span class="cl">    return 1
</span></span><span class="line"><span class="cl">else
</span></span><span class="line"><span class="cl">    return 0
</span></span><span class="line"><span class="cl">end
</span></span></code></pre></div><p>库存扣减成功返回1， 库存扣减失败返回0；</p>
<h4 id="数据库批量合并扣库存">数据库批量合并扣库存</h4>
<blockquote>
<p>使用redis控制库存增减虽然很快，但是如果服务器意外宕机，或者交易失败，库存回滚就会比较麻烦，特别是redis事务和数据库事务不在一个事务里，无法做到强一致性，不可避免的会产生一些数据不一致问题。因此我们需要在数据库层面也进行库存同步修改操作，具体操作流程如下：</p>
</blockquote>
<ol>
<li>用户下单，redis减库存成功，数据库插入下单记录</li>
<li>后台服务器每秒钟同步统计该商品所有新增库存订单，按照下单顺序，汇总库存修改总额，更新库存。</li>
<li>在上一步中，如果出现库存不足情况，或者用户超出了购买限制，标记为下单失败，如已支付，发起退款操作。</li>
<li>库存真正扣减成功后再进行发货操作。</li>
<li>定时同步数据库剩余库存到redis，redis库存值和数据库库存值可以不一致，最终下单是否成功，前台/客户端需要向服务端轮询该订单是否实际扣库存成功</li>
<li>当redis库存数量为0时，后台更新数据库剩余库存到redis。</li>
<li>5，6步时必须手段， 不然会出现用户下单成功了但是被库存不足砍单情况， 非用户原因下这样会引起纠纷的</li>
</ol>
<blockquote>
<p>通过上面的操作，我们成功把数据的多个并发修改操作合成了一个数据库的修改操作，大大减轻了数据库锁等待问题。</p>
</blockquote>
<h4 id="数据库分片扣库存">数据库分片扣库存</h4>
<blockquote>
<p>当商品数量很多时，我们根据商品ID可以把商品分片到多个数据库。这样对一个数据库的修改操作就可以分散到多个数据库。当订单量很大，数据库出现插入压力时，可以根据用户ID分片，把同一商品的不同用户订单分别存储到不同数据库，减轻单一数据库压力。</p>
</blockquote>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/%E7%A7%92%E6%9D%80/">秒杀</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-07-31-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">
        <h2 class="post-title">第三方网站数据爬取经验总结</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-07-31
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;68&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <blockquote>
<p>尝试爬取过大大小小很多网站，有些许体会心得。根据个人难易成度感觉排序，开发语言主要是Java。</p>
</blockquote>
<h3 id="主要工具">主要工具</h3>
<ul>
<li>Chrome DevTools 用来查看页面请求流程，请求头信息，响应信息，cookie</li>
<li>Fiddler 有些页面有重定向，对于此类页面Chrome DevTools 不太好看到请求流程，可以使用Fiddler抓包，另外Fiddler也可以抓一些移动端APP的报文</li>
<li>Jsoup Java HTML解析器</li>
<li>httpclient-fluent Java HTTP请求库</li>
<li>selenium Java库 用来控制selenium</li>
<li>各浏览器对应webdriver 用来控制浏览器，和selenium搭配使用</li>
</ul>
<h3 id="常见问题">常见问题</h3>
<ol>
<li>有用户名密码验证</li>
<li>登录有图形验证码</li>
<li>登录有滑动验证码</li>
<li>登录有控件</li>
<li>请求过程中存在数据加密，登录过程中存在多个页面重定向，多次重定向过程中生成cookie</li>
<li>请求响应的数据有加密，或者存在于JS或者HTML代码中</li>
</ol>
<h3 id="解决办法">解决办法</h3>
<h4 id="1-有用户名密码验证">1. 有用户名密码验证</h4>
<blockquote>
<p>对于有用户名密码验证的网站，有两种方式</p>
<ol>
<li>手工在浏览器登录，复制cookie至代码中，在代码中使用该cookie登录</li>
<li>分析登录接口，使用代码，登陆后获得cookie，然后爬取数据</li>
</ol>
</blockquote>
<h4 id="2-登录有图形验证码">2. 登录有图形验证码</h4>
<blockquote>
<ol>
<li>手工登录，登陆后复制cookie</li>
<li>在代码登录前，先调用获取验证码接口获得新验证码，存储至本地，对于简单的验证码，可以用ocr软件训练识别，对于负责验证码，调用第三方打码网站识别(12306刷票就是接的第三方打码)</li>
</ol>
</blockquote>
<h4 id="3-登录有滑动验证码">3. 登录有滑动验证码</h4>
<p><strong>接入滑动验证码是有成本的，有用户使用成本和费用成本</strong></p>
<blockquote>
<ol>
<li>手工登录，复制cookie</li>
<li>对于支持很多用户手工登录，可以设计为在移动端APP内打开，然后结合WebView脚本注入来实现登录，具体流程如下：
a. 用户在APP内通过WebView打开页面
b. APP注入JS脚本，检测登录状态，控制页面在APP内的打开样式
c. 用户登录，脚本检测到用户登录成功后，APP获得WebView Cookie，然后把Cookie发送给服务器
d. 如果该Cookie支持多IP访问，直接在服务器端爬取数据
e. 如果该Cookie不支持多IP访问，客户端爬取数据，传递到服务器，客户端APP尽量定时打开页面刷新Cookie</li>
</ol>
</blockquote>
<p><strong>上述方法可以破解一般的滑动验证码登录，对于阿里云的WAF验证也可破解，在通过服务器IP爬取数据的过程中， 在请求过程中，服务器本身尽量把自己模拟出代理服务器，尽量避免第三方服务器的一些IP访问限制</strong></p>
<h4 id="4-登录有控件">4. 登录有控件</h4>
<h5 id="登录有控件只能在windows上破解"><strong>登录有控件只能在windows上破解</strong></h5>
<blockquote>
<ol>
<li>手动登录，复制cookie后爬取</li>
<li>使用selenium打开浏览器，移动鼠标至控件位置，点击聚焦，模拟键盘输入， 输入完成之后找到登录按钮，点击提交</li>
<li>登录完成后从selenium拿到浏览器cookie，同步至程序，使用程序进行后面的爬取解析工作</li>
</ol>
</blockquote>
<h4 id="5-请求过程中存在数据加密登录过程中存在多个页面重定向多次重定向过程中生成cookie">5. 请求过程中存在数据加密，登录过程中存在多个页面重定向，多次重定向过程中生成cookie</h4>
<blockquote>
<p>使用selenium完成整个登录流程，登录完成后同步cookie到程序爬取</p>
</blockquote>
<h4 id="6-请求响应的数据有加密或者存在于js或者html代码中">6. 请求响应的数据有加密，或者存在于JS或者HTML代码中</h4>
<blockquote>
<p>使用selenium打开加载整个页面，加载完成后从selenium获取页面代码至程序，接续爬取。</p>
</blockquote>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/%E7%88%AC%E8%99%AB/">爬虫</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-07-30-docker%E4%BD%BF%E7%94%A8nexus%E4%BD%9C%E4%B8%BA%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/">
        <h2 class="post-title">Docker使用nexus作为镜像仓库</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-07-30
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;20&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <p><strong>登录docker repo</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> docker login -u admin -p admin123 192.168.135.73:8082
</span></span></code></pre></div><p><img src="/static/attachment/20200806/e45c0972c79f4bd4a26b588bf484480a.png" alt="">
<strong>给镜像打tag:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker tag jdk:jre8 192.168.135.73:8082/jdk:jre8
</span></span></code></pre></div><p><img src="/static/attachment/20200806/5d80c64dd48e4711892f253836270589.png" alt="">
<img src="/static/attachment/20200806/8a00f61f042941dd961d2c85298613c0.png" alt=""></p>
<p><strong>上传镜像:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker push 192.168.135.73:8082/jdk:jre8
</span></span></code></pre></div><p><img src="/static/attachment/20200806/18b165cb61174d61b515526c6b80f91d.png" alt="">
<strong>下载镜像:</strong>
<img src="/static/attachment/20200806/23b36e8681c4458cba118a57c8b05342.png" alt="">
<strong>nexus中镜像:</strong>
<img src="/static/attachment/20200806/60a5febd30b44f559283adaef491e46e.png" alt=""></p>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/%E8%BD%AF%E4%BB%B6/">软件</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-07-30-2pc-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%AE%97%E6%B3%95/">
        <h2 class="post-title">2PC - 分布式场景下的两阶段提交算法</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-07-30
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;37&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h3 id="概念">概念</h3>
<blockquote>
<p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
</blockquote>
<blockquote>
<p><strong>两个角色: 协调者，参与者</strong>。</p>
</blockquote>
<blockquote>
<p><strong>所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。</strong></p>
</blockquote>
<h3 id="过程">过程</h3>
<h4 id="第一阶段提交请求阶段">第一阶段(提交请求阶段):</h4>
<blockquote>
<ol>
<li>协调者询向所有参与者节点询问, 是否可以执行提交操作, 并开始等待参与者节点响应</li>
</ol>
</blockquote>
<ol start="2">
<li>参与者节点执行询问发起为止所有事务操作, 并将undo信息和redo信息写入日志.</li>
<li>各参与者节点响应协调者发起的询问, 如果参与者节点的事务操作执行成功, 就返回一个&quot;同意&quot;消息, 如果失败, 就返回一个&quot;中止消息&quot;</li>
</ol>
<h4 id="第二阶段提交执行阶段">第二阶段(提交执行阶段):</h4>
<blockquote>
<p>当协调者获得所有节点的响应为&quot;同意&quot;时:</p>
</blockquote>
<ol>
<li>协调者想所有节点发起&quot;正式提交&quot;请求</li>
<li>参与者节点正式完成操作, 并释放整个事务期间占用的资源</li>
<li>参与者节点向协调者节点发送&quot;完成&quot;消息</li>
<li>协调者节点收到所有参与者节点反馈的&quot;完成&quot;消息后, 完成事务.</li>
</ol>
<h4 id="回滚阶段">回滚阶段</h4>
<blockquote>
<p>如果任一参与者节点在第一阶段返回了&quot;中止&quot;消息, 或者协调者节点在第一阶段询问时间超时之前无法获得所有节点的响应信息</p>
</blockquote>
<ol>
<li>协调者向所有参与者节点发起&quot;回滚操作&quot; 的请求</li>
<li>参与者使用第一阶段的undo信息执行回滚操作, 并占用第一阶段锁定的资源</li>
<li>参与者节点向协调者发送&quot;回滚完成&quot; 消息</li>
<li>协调者收到所有节点发起的&quot;回滚完成&quot;消息后取消事务</li>
</ol>
<blockquote>
<p>两段提交最大的问题就是如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键点所在，因此在两阶段的基础上衍生出了三阶段提交算法，三阶段先询问，再锁资源，提交。</p>
</blockquote>
<h4 id="两阶段流程图来自维基百科">两阶段流程图(来自维基百科)</h4>
<p><img src="/static/attachment/20200805/c30f740a240a40feb52c955b16137d1f.jpg" alt=""></p>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-07-29-docker-%E5%88%9B%E5%BB%BAoracle-server-jre-%E9%95%9C%E5%83%8F/">
        <h2 class="post-title">docker 创建Oracle Server Jre 镜像</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-07-29
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;107&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        先上Dockerfile配置: FROM centos:7 # 维护者 MAINTAINER your-name # 将jdk压缩包添加到容器的 /root 目录，解压后目录名称为jdk1.8.0_211 #ADD server-jre-8u251-linux-x64.tar.gz /root COPY jre /jre # 配置JAVA_HOME环境变量 ENV JAVA_HOME /jre/ # 将JAVA_HOME/bin 添加至PATH环境变量 ENV PATH $JAVA_HOME/bin:$PATH # 启动容器执行的命令，仅用于验证安装配置是否正确，生产环境使用需注释后再build #CMD java -version #ENTRYPOINT [&#34;/jre/bin/java&#34;, &#34;-version&#34;] 步骤: 下载oracle server jre, 我当前下载下来是8u251版本 上传到centos, Dockfile同层目录下 解压缩, 修改解压缩后文件夹名字为jre 在当前目录执行docker build: docker build -t jdk:jre8 . 执行完成后, 镜像被保存到本地仓库, jdk 为 image名称, jre为版本, -t 代表 tag 遇到的坑: 不能FROM scratch, 继承自空白镜像连sh命令都没有, Dockerfile 中的CMD和ENTRYPOINT命令是以sh -c xxxxx 执行的, 没sh命令根本执行不了 不能FROM busybox:latest , 也是一样找不到sh命令, docker本身是去找bash, 但是busybox 不包含bash 不能FROM alpine:latest, 理由同上, 也是找不到bash 最后FROM centos:7 好了
        <a href="https://hzren.github.io/blog/blog/2020-07-29-docker-%E5%88%9B%E5%BB%BAoracle-server-jre-%E9%95%9C%E5%83%8F/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/%E8%BD%AF%E4%BB%B6/">软件</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://hzren.github.io/blog/blog/2020-07-29-spring-component-sacn-%E6%89%AB%E6%8F%8F%E5%8A%A0%E8%BD%BD%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">
        <h2 class="post-title">Spring component-sacn 扫描加载全流程分析</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-07-29
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;4&nbsp;分钟
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;789&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;renhongzhen
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        @ComponentScan 如果你理解了ComponentScan， 你就理解了Spring。 Spring是一个依赖注入(dependency injection)框架。所有的内容都是关于bean的定义及其依赖关系。 定义Spring Beans的第一步是使用正确的注解-@Component或@Service或@Repository或@Controller等等。 在Spring容器启动过程中，Spring并不知道你定义了哪个bean，除非它知道从哪里可以找到这个bean。
Spring 找到Bean的集中方式 XML文件定义Bean Configuration类通过Java 风格定义Bean元素 ComponentScan 自动扫描加载Bean 通过XML定义加载Bean Spring 解析XML元素，根据元素内配置的Bean定义，找到Bean的package和className，通过constructor配置直接反射生成Bean对象
Configuration类通过Java 风格定义Bean元素 Spring容器找到@Configuration注解所在类，通过反射获取其所有方法，依次调用标有@Bean注解的方法，生成对应Bean对象
通过ComponentScan动态扫描加载Bean 对于Spring容器来说，这种方式是最复杂的方式，也是最慢的方式，在Spring容器启动的时候，Spring并不知道其要加载的Bean有多少，甚至连这些Bean的Class文件所在位置在那里都不知道，加载这些Bean，对于Spring容器来说，是一个漫长的过程。 这些Spring要加载的Bean的Class文件，可能位于Jar包当中，也可能位于Class文件当中，Spring需要去查看每个Jar包来寻找这个Class文件。
@ComponentScan加载代码分析 通过ComponentScanBeanDefinitionParser类来支持@ComponentScan注解 参见 org.springframework.context.config.ContextNamespaceHandler
@Override public void init() { registerBeanDefinitionParser(&#34;property-placeholder&#34;, new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(&#34;property-override&#34;, new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(&#34;annotation-config&#34;, new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(&#34;component-scan&#34;, new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(&#34;load-time-weaver&#34;, new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(&#34;spring-configured&#34;, new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(&#34;mbean-export&#34;, new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(&#34;mbean-server&#34;, new MBeanServerBeanDefinitionParser()); } org.springframework.context.annotation.ComponentScanBeanDefinitionParser 主要逻辑如下 protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { boolean useDefaultFilters = true; if (element.
        <a href="https://hzren.github.io/blog/blog/2020-07-29-spring-component-sacn-%E6%89%AB%E6%8F%8F%E5%8A%A0%E8%BD%BD%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" class="post-read-more">[阅读全文]</a>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://hzren.github.io/blog//tags/java/">Java</a>&nbsp;
        
        <a href="https://hzren.github.io/blog//tags/spring/">Spring</a>&nbsp;
        
    </div>
    

</article>
          
        </div>

        
          <ul class="pager main-pager">
            
              <li class="previous">
                <a href="https://hzren.github.io/blog/page/4/">&larr; 上一页</a>
              </li>
            
            
              <li class="next">
                <a href="https://hzren.github.io/blog/page/6/">下一页 &rarr;</a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>

      
    <div class="page-meta">
  
  
  
</div>


  
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
		
		  <a href="mailto:hzren@outlook.com" title="Email me">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.facebook.com/username" title="Facebook">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://github.com/username" title="GitHub">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://gitlab.com/username" title="GitLab">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-gitlab fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://bitbucket.org/username" title="Bitbucket">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-bitbucket fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://twitter.com/username" title="Twitter">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://username.slack.com/" title="Slack">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-slack fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://reddit.com/u/username" title="Reddit">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-reddit-alien fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://linkedin.com/in/username" title="LinkedIn">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.xing.com/profile/username" title="Xing">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-xing fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://stackoverflow.com/users/XXXXXXX/username" title="StackOverflow">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.snapchat.com/add/username" title="Snapchat">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-snapchat-ghost fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.instagram.com/username" title="Instagram">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-instagram fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.youtube.com/user/username" title="Youtube">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-youtube fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://soundcloud.com/username" title="SoundCloud">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-soundcloud fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://open.spotify.com/user/username" title="Spotify">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-spotify fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://username.bandcamp.com/" title="Bandcamp">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-bandcamp fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://itch.io/profile/username" title="Itch.io">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-gamepad fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://vk.com/username" title="VK">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-vk fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://paypal.me/username" title="PayPal">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-paypal fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://telegram.me/username" title="Telegram">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-telegram fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://500px.com/username" title="500px">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-500px fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://codepen.io/username" title="CodePen">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-codepen fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.kaggle.com/username" title="kaggle">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-kaggle fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a rel="me"href="https://url" title="Mastodon">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-mastodon fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://weibo.com/username" title="Weibo">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-weibo fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://discord.gg/invite%20code%20%28https://discord.gg/XXXXXXX%29" title="Discord">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-discord fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://www.strava.com/athletes/userid" title="Strava">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-strava fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="/blog/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://hzren.github.io/blog/">renhongzhen</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2022
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://hzren.github.io/blog/">Code Mark</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          由 <a href="https://gohugo.io">Hugo v0.109.0</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> 移植自 <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://hzren.github.io/blog/js/main.js"></script>
<script src="https://hzren.github.io/blog/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://hzren.github.io/blog/js/load-photoswipe.js"></script>









    
  </body>
</html>

