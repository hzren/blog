<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Network on Code Mark</title>
    <link>https://hzren.github.io/tags/network/</link>
    <description>Recent content in Network on Code Mark</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>hzren@outlook.com (renhongzhen)</managingEditor>
    <webMaster>hzren@outlook.com (renhongzhen)</webMaster>
    <lastBuildDate>Tue, 19 Jan 2021 18:30:32 +0800</lastBuildDate><atom:link href="https://hzren.github.io/tags/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux网络</title>
      <link>https://hzren.github.io/blog/2021-01-19-linux%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 19 Jan 2021 18:30:32 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2021-01-19-linux%E7%BD%91%E7%BB%9C/</guid>
      <description>摘自 倪朋飞-极客时间-Linux性能优化实战
Linux 通用 IP 网络栈的示意图：
网卡是发送和接收网络包的基本设备。在系统启动过程中，网卡通过内核中的网卡驱动程序注册到系统中。而在网络收发过程中，内核通过中断跟网卡进行交互。再结合前面提到的 Linux 网络栈，可以看出，网络包的处理非常复杂。所以，网卡硬中断只处理最核心的网卡数据读取或发送，而协议栈中的大部分逻辑，都会放到软中断中处理。
网络包的接收流程 当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；然后通过硬中断，告诉中断处理程序已经收到了网络包。
接着，网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到sk_buff 缓冲区中；然后再通过软中断，通知内核收到了新的网络帧。
接下来，内核协议栈从缓冲区中取出网络帧，并通过网络协议栈，从下到上逐层处理这个网络帧。比如:
在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。传输层取出 TCP 头或者 UDP 头后，根据 &amp;lt; 源 IP、源端口、目的 IP、目的端口 &amp;gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。
最后，应用程序就可以使用 Socket 接口，读取到新接收到的数据了。
网络包的发送流程 网络包的发送流程就是上图的右半部分，很容易发现，网络包的发送方向，正好跟接收方向相反。
首先，应用程序调用 Socket API（比如 sendmsg）发送网络包。在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。
当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。传输层取出 TCP 头或者 UDP 头后，根据 &amp;lt; 源 IP、源端口、目的 IP、目的端口 &amp;gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。</description>
    </item>
    
    <item>
      <title>路由条目</title>
      <link>https://hzren.github.io/blog/2021-01-13-%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE/</link>
      <pubDate>Wed, 13 Jan 2021 10:13:06 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2021-01-13-%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE/</guid>
      <description>ip route命令的输出解释。
获取工具 ip命令包含在net-tools包中，可以通过安装net-tools包获得该命令。
常见用法 执行man ip route
IP-ROUTE(8) Linux IP-ROUTE(8) NAME ip-route - routing table management SYNOPSIS ip [ ip-OPTIONS ] route { COMMAND | help } ip route { list | flush } SELECTOR ip route save SELECTOR ip route restore ip route get ADDRESS [ from ADDRESS iif STRING ] [ oif STRING ] [ tos TOS ] ip route { add | del | change | append | replace } ROUTE SELECTOR := [ root PREFIX ] [ match PREFIX ] [ exact PREFIX ] [ table TABLE_ID ] [ proto RTPROTO ] [ type TYPE ] [ scope SCOPE ] ROUTE := NODE_SPEC [ INFO_SPEC ] NODE_SPEC := [ TYPE ] PREFIX [ tos TOS ] [ table TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ] [ metric METRIC ] INFO_SPEC := NH OPTIONS FLAGS [ nexthop NH ] .</description>
    </item>
    
    <item>
      <title>容器网络</title>
      <link>https://hzren.github.io/blog/2021-01-12-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 12 Jan 2021 10:43:21 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2021-01-12-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</guid>
      <description>容器网络的核心是和物理网络实现网络隔离，物理网络对于容器来说为虚拟的，不可见的。
概念 Overlay / 覆盖网络
覆盖网络（Overlay network）是一种建立在另一网络之上的计算机网络。
覆盖网络中的节点可以被认为是通过虚拟或逻辑链接相连，其中每个链接对应一条路径（Path）。节点之间也可能通过下层网络中的多个物理连接实现相连。
Flannel Flannel有UDP和VXLAN两种方案
使用UDP实现Overlay网络 Flannel的覆盖网络：Flannel另创建了一个网络100.96.0.0/16，它是一个更大的网络，可以容纳2个¹⁶（65536）地址，它覆盖所有kubernetes节点，每个pod将在这个范围内分配一个地址。
在主机docker网络中：在每个主机中，flannel为该主机中的所有pod分配了一个100.96.x.0/24网络，它可以容纳2⁸（256）个地址。docker网桥docker0将使用此网络创建新容器。
通过这种设计，每个容器都有自己的IP地址，都属于覆盖子网100.96.0.0/16。同一主机内的容器可以通过docker网桥docker0相互通信。
为了在主机间与覆盖网络中的其他容器进行通信，flannel使用内核路由表和UDP封装来实现它，下面几节将对此进行解释。
发包过程 假设节点1中IP地址为100.96.1.2的容器（我们称之为container-1）想要连接到节点2中IP地址为100.96.2.3的容器（我们称之为container-2）:
第一个container-1创建一个src:100.96.1.2-&amp;gt;dst:100.96.2.3的IP数据包，该数据包将直接被发送到容器的网关-docker0网桥。
在每个主机中，flannel会运行一个名为flanneld的守护进程，flanneld会在内核的路由表中创建一些路由规则，节点1的路由表一般是这样的：
admin@ip-172-20-33-102:~$ ip route default via 172.20.32.1 dev eth0 100.96.0.0/16 dev flannel0 proto kernel scope link src 100.96.1.0 100.96.1.0/24 dev docker0 proto kernel scope link src 100.96.1.1 172.20.32.0/19 dev eth0 proto kernel scope link src 172.20.33.102 如上所见，包的目的地址100.96.2.3落在更大的覆盖网络100.96.0.0/16中，因此它符合第二条规则100.96.0.0/16 dev flannel0 proto kernel scope link src 100.96.1.0，现在根据路由规则内核把包发送到flannel0虚拟网卡。
100.96.0.0/16 dev flannel0 proto kernel scope link src 100.</description>
    </item>
    
    <item>
      <title>一次内网到公网_公网导内网的数据链路过程</title>
      <link>https://hzren.github.io/blog/2021-01-06-%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E5%88%B0%E5%85%AC%E7%BD%91_%E5%85%AC%E7%BD%91%E5%AF%BC%E5%86%85%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 06 Jan 2021 10:32:30 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2021-01-06-%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E5%88%B0%E5%85%AC%E7%BD%91_%E5%85%AC%E7%BD%91%E5%AF%BC%E5%86%85%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E8%BF%87%E7%A8%8B/</guid>
      <description>以一次从内网到公网，公网到内网的数据交互过程来梳理整个网络链路。
网络拓扑图 MAC地址是一个局域网内才有效的地址。因而，MAC地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于IP地址是否改变。不改变IP地址的网关，我们称为转发网关；改变IP地址的网关，我们称为NAT网关。
每到一个新的局域网，MAC都是要变的，但是IP地址都不变。在IP头里面，不会保存任何网关的IP地址。所谓的下一跳是，某个IP要将这个IP地址转换为MAC放入MAC头
上图中： 手机A1， A2, 交换机A，路由器A组成了用户的小内网，以NAT的方式访问外网。 BGP网关ABCD组成了外网互联，根据IP地址转发路由
请求出内网 手机A1需要向服务器B1发送数据， 手机A1发现B1和其不在同一网段 a. 手机A1在内网内广播获取网关(路由器A)IP的ARP请求 b. 网关(路由器A)收到ARP请求后，以单播的形式向手机A1发送ARP响应，返回其MAC地址 c. 内网中其他设备收到ARP请求后发现不是寻找本设备忽略该数据包 手机A1拿到网关(路由器A)MAC地址后，封装二层数据包；目标MAC地址是网关MAC，三层数据包里面的目的IP是服务器B1的公网IP 交换机A1在收到手机A1发来的数据包后，根据从端口学习到的MAC地址映射将数据包从响应端口法网路由器A 路由器A收到数据报文后，对比MAC数据报文中的MAC地址 a. 不是发往自己的，丢弃 b. 是发往自己的，检查三层数据包IP地址 请求在公网 路由器A根据三层目标IP地址和自身的公网路由规则，得到下一跳网关（BGP网关B）IP地址，然后根据ARP获得的下一条网关MAC地址，重组数据包：
源IP替换为自身公网IP 对于TCP，UDP数据，修改三层数据包端口，建立NAT映射，所有来自该内网IP+端口的数据都会经公网IP+一固定端口转发；公网IP上该固定端口收到的数据都会被转发到对应内网IP+端口上 源MAC地址替换为自身公网网卡MAC 目标IP不变 目标IP替换为下一跳网关MAC地址 BGP网关B收到数据包后判断目标IP是否在本网关所对应的子网中，发现不在，继续转发数据包至BGP网关D，转发过程如下：
源IP不变 源MAC地址替换为自身公网网卡MAC 目标IP不变 目标IP替换为下一跳网关MAC地址 BGP网关发现目标IP在本网关所对应的子网中，对数据包进行转发到服务器B1
服务器B1收到数据包后，检查目标MAC地址，确认是自己的，收包，否则丢弃
响应在公网 服务器B返回数据包 目标IP：路由器A公网出口IP 目标MAC ： 路由器A公网出口MAC 源IP ： 自身公网IP 源MAC : 自身公网MAC 过程同请求在公网
IP报文的请求路径和响应路径很可能是不同的，具体须经由网关路由规则确定。
响应在客户端内网 路由器A公网网口收到响应数据包，在确定目标MAC地址是自身后， 根据路由/转发规则和三层数据包里面的链接标识确定数据包最终转发到那台内网机器。
TCP/UDP请求 根据NAT映射关系，修改数据包数据 修改三层数据包目的IP为映射的内网机器IP 修改三层数据包目的端口为映射IP的映射端口 修改 转发修改后的数据包到固定内网IP和端口上。 ICMP ICMP协议无端口，根据三层数据包里面的ICMP Query ID确定内网IP。
原文见： IETF文档 3.1章节</description>
    </item>
    
    <item>
      <title>TCP / UDP 总结</title>
      <link>https://hzren.github.io/blog/2020-08-19-tcp-udp-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 19 Aug 2020 15:04:38 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-19-tcp-udp-%E6%80%BB%E7%BB%93/</guid>
      <description>send()最大可以接受多少字节的数据？ 函数层面无限制，超过缓冲区大小函数会block
TCP接到send()发送的字节，会立马保持原封不动发送吗？ 不确定！
TCP会先将这些数据放在自己的仓库（发送缓冲区），至于什么时候发，每次发多少，已经不是应用层所能左右的了。什么时候发，一次发多少取决于不同算法，有RCP_NODELAY配置，有MSS限制TCP分组最大长度。
TCP是基于字节流发送，可能将用户的一次数据发送砍成多个segment发送，也可能将多次应用层的发送合并在一个segment发送。而决定TCP一次最大能发segment的大小则和MSS有关，而MSS最终和MTU有关。
分片是非常不利的选择，当前网络所做的很多努力都是极力避免分片！
TCP MSS真的可以避免分片吗？ TCP连接的双方依据本地物理链路的MTU，按照以上的公式计算出本地的MSS，然后双方交换各自的MSS，双方会选择两者中小的MSS来继续通信。但有没有想过，如果路径中的MTU比连接双方的MTU都小，是不是分片就无法避免了？答案是肯定的！
这个时候必须分片，不分片就会丢，这是DF = 1的状况，需要给源主机发送ICMP消息，问题是ICMP消息能到达源主机吗？如果不能到达，通信就会断，即使TCP有重传机制。
能到达源主机，源的TCP意识到这一点，会将重传的报文重新切片，重新发送，这没有什么问题，只是耽误一点时间而已。
DF = 0时，可以直接分片，尽管耗费很多分片的资源，到达目的地再重组，也要耗费一点资源。
问题是，没有端口号的分片，经过安全设备时，可能会遇到障碍，这同样会造成通信的障碍。
看，一旦分片造成多大的麻烦，麻烦意味着CPU资源的耗费，为了避免这些不必要的动作，只要不分片，一切都会变的简单。
UDP UDP是块式消息，UDP本身没有任何分片的能力，也没有任何重传的能力，这些能力需要依赖应用层、IP层。
计算机网络发展到今天，大家已经形成了一个共识，如果用户的数据确实需要分片传输，务必保证分片的动作由应用层来完成，到达目的地由应用层将字节流，再整理成有意义的消息块。
TCP丢包 路由器或交换机，一旦TCP流量暴力来袭时，会尽最大能力转发流量，如果流量持续增长，流量流速&amp;gt; 物理线路速率，用缓存将多余的流量缓存在队列里，一旦线路空闲，再发送出去。
但如果多余的流量&amp;gt; 缓存的空间，无法容纳的流量将会统统丢弃，cisco官方的名词称之为尾丢( Tail Drop)。
所以缓存只能应付临时的突发流量（Burst Traffic）, 只要多余的突发流量&amp;lt;= 缓存空间，就不会丢弃。
但是缓存无法应付诸如TCP 指数增长流量，唯一的办法就是尾丢。
网络接口出方向的 ”out dircard”是正常的，TCP slow start算法就是依靠丢包来实现的，至于哪里要丢，取决于端到端哪条链路的可用带宽最小，记住可用带宽不是接口的最大带宽，可用带宽是真正可以利用的带宽。
因为两将军问题，在TCP协议中，谁是字节数据的owner，谁才对字节数据负责！数据的接收方并不需要为字节数据负责，被动确认（Passive ACK）一次即可。</description>
    </item>
    
    <item>
      <title>ICMP Ping traceroute</title>
      <link>https://hzren.github.io/blog/2020-08-18-icmp-ping-traceroute/</link>
      <pubDate>Tue, 18 Aug 2020 16:52:07 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-18-icmp-ping-traceroute/</guid>
      <description>Ping和traceroute都基于ICMP协议工作。
ICMP 互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网的核心协议之一，用于在网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题的反馈。通过这些信息，可以对所发生的问题作出诊断，然后采取适当的措施解决。
ICMP基于IP协议，通常不由网络程序直接使用，除了 ping 和 traceroute 这两个特别的例子。 IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6。
技术细节 ICMP通常用于返回的错误信息或是分析路由。ICMP错误消息总是包括了源数据并返回给发送者。 ICMP错误消息例子之一是TTL值过期。
每个路由器在转发数据报的时候都会把IP包头中的TTL值减1。如果TTL值为0，“TTL在传输中过期”的消息将会回报给源地址。 每个ICMP消息都是直接封装在一个IP数据包中的，因此，和UDP一样，ICMP是不可靠的。
很多常用的工具是基于ICMP消息的。traceroute 是通过发送包含有特殊的TTL的包，然后接收ICMP超时消息和目标不可达消息来实现的。 ping 则是用ICMP的&amp;quot;Echo request&amp;quot;（类别代码：8）和&amp;quot;Echo reply&amp;quot;（类别代码：0）消息来实现的。
报文结构 ICMP报头从IP报头的第160位开始（IP首部20字节）（除非使用了IP报头的可选部分）。
Type - ICMP的类型,标识生成的错误报文Code - 进一步划分ICMP的类型,该字段用来查找产生错误的原因.；例如，ICMP的目标不可达类型可以把这个位设为1至15等来表示不同的意思。Checksum - Internet校验和（RFC 1071），用于进行错误检查，该校验和是从ICMP头和以该字段替换为0的数据计算得出的。Rest of Header - 报头的其余部分，四字节字段，内容根据ICMP类型和代码而有所不同。报文类型 ICMP 报文有很多的类型，不同的类型有不同的代码。最常用的类型是主动请求为 8，主动请求的应答为 0。 ICMP有两大类报文类型: 查询报文类型, 差错报文类型
查询报文类型 主动发起的，主动应答的，对应 ICMP 的查询报文类型就是查询报文类型。例如，常用的ping 就是查询报文，是一种主动请求，并且获得主动应答的 ICMP 协议。所以，ping 发的包也是符合 ICMP协议格式的，只不过它在后面增加了自己的格式。 对 ping 的主动请求，进行网络抓包，称为ICMP ECHO REQUEST。同理主动请求的回复，称为ICMP ECHO REPLY。比起原生的 ICMP，这里面多了两个字段，一个是标识符。在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。
差错报文类型 异常情况引起的，对应 ICMP 的差错报文类型。</description>
    </item>
    
    <item>
      <title>Linux IP地址 DHCP</title>
      <link>https://hzren.github.io/blog/2020-08-18-linux-ip%E5%9C%B0%E5%9D%80-dhcp/</link>
      <pubDate>Tue, 18 Aug 2020 15:06:02 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-18-linux-ip%E5%9C%B0%E5%9D%80-dhcp/</guid>
      <description>配置 IP 地址 可以使用ifconfig，也可以使用 ip addr。设置好以后，将网卡 up 一下，就可以开始工作了。 使用 net-tools：
$ sudo ifconfig eth1 10.0.0.1/24 $ sudo ifconfig eth1 up 使用 iproute2：
$ sudo ip addr add 10.0.0.1/24 dev eth1 $ sudo ip link set up eth1 如果配置一个和谁都不搭边的地址呢？例如，旁边的机器都是 192.168.1.x，我非得配置一个 16.158.23.6，会出现什么现象呢？
不会出现任何现象，就是包发不出去呗。
为什么发不出去？192.168.1.6 就在你这台机器的旁边，甚至是在同一个交换机上，而你把机器的地址设为了16.158.23.6。在这台机器上，你企图去 ping 192.168.1.6，你觉得只要将包发出去，同一个交换机的另一台机器马上就能收到，是这样的吗？
可是 Linux 系统不是这样的，它没你想得那么智能。你用肉眼看到那台机器就在旁边，它则需要根据自己的逻辑进行处理。只要是在网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层。 所以，虽然它有自己的源 IP 地址 16.158.23.6，也有目标 IP 地址 192.168.1.6，但是包发不出去，这是因为 MAC 层还没填。自己的 MAC 地址自己知道，这个容易。但是目标 MAC 填什么呢？是不是填 192.168.1.6 这台机器的 MAC 地址呢？ 当然不是。Linux 首先会判断，要去的这个地址和我是一个网段的吗，或者和我的一个网卡是同一网段的吗？只有是一个网段的，它才会发送 ARP 请求，获取 MAC 地址。 如果发现不是,Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。 如果你配置了网关的话，Linux 会获取网关的 MAC 地址，然后将包发出去。对于 192.</description>
    </item>
    
    <item>
      <title>专用网络（内网 / 私有网络）</title>
      <link>https://hzren.github.io/blog/2020-08-17-%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E5%86%85%E7%BD%91-%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 17 Aug 2020 17:34:48 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-17-%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E5%86%85%E7%BD%91-%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C/</guid>
      <description>概念 在互联网的地址架构中，专用网络是指遵守RFC 1918（IPV4）和RFC 4193（IPV6）规范，使用专用IP地址空间的网络。私有IP无法直接连接互联网，需要使用网络地址转换（Network Address Translator，NAT）或者代理服务器 （proxy server）来实现。与公网IP相比，私有IP是免费的，同时节省了IP地址资源，适合在局域网使用。
用途 私有IP无法直接被互联网所访问，因此，相对于公网IP地址，它更加安全。私有IP常被用于家庭，学校和企业的局域网。IPv4私有地址 共享地址 Shared Address Space（RFC 6598），IANA于2012年将100.64.0.0/10定义用于电信级NAT场景。这些地址与RFC1918中定义的私有IP是不同的，只能用于运营商的内部网络，虽然在某些特性中与私有IP相同，但在定义上不能划为私有地址（更不是公用地址）。
IPv6私有地址 IPv6的私有IP定义在RFC 4193， 地址块fc00 :: / 7已保留。这些地址称为唯一本地地址（Unique Local Addresses，ULA）。 它们被定义为单播地址，并在路由前缀中包含一个40位的随机数，以防止在两个私有网络互连时发生冲突。 尽管在本地使用，但唯一本地地址的IPv6地址范围是全局的。</description>
    </item>
    
    <item>
      <title>子网 子网掩码 无类别域间路由</title>
      <link>https://hzren.github.io/blog/2020-08-17-%E5%AD%90%E7%BD%91-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81-%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Mon, 17 Aug 2020 16:54:10 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-17-%E5%AD%90%E7%BD%91-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81-%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/</guid>
      <description>子网 在因特网协议（Internet Protocol，IP）中，子网指的是从分类网络中划分出来的一部分。
具有相同的前半部分地址的一组IP地址，可以利用地址的前半部分划分组。在一个IP网络中划分子网使我们能将一个单一的大型网络分成若干个较小的网络。在最初引入这个概念的时候，IPv4还未引入分类网络这个概念。引入划分子网这个概念的目的是为了允许一个单一的站点能拥有多个局域网。在引入了分类网络号之后，这个概念仍然有它的用处，因为它减少了因特网路由表中的表项数量（通过隐藏一个站点内部所有独立子网的相关信息）。此外它还带来了一个好处，那就是减少了网络开销，因为它将接收IP广播的区域划分成了若干部分。
子网掩码 子网掩码是用来划分IP地址中哪一部分是网络号，哪一部分是机器号。
「网络掩码」又叫「子网掩码」、「地址掩码」、「子網路遮罩」（subnet mask），它是一种用来指明一个IP地址的哪些位标识的是主机所在的网络地址以及哪些位标识的是主机地址的位掩码。 通常情况下，子网掩码的表示方法和地址本身的表示方法是一样的。在IPv4中，就是点分十进制四组表示法（四个取值从0到255的数字由点隔开，比如255.128.0.0）或表示为一个八位十六进制数（如FF.80.00.00，它等同于255.128.0.0），后者用得较少。 另一种更为简短的形式叫做无类别域间路由（CIDR）表示法，它给出的是一个地址加上一个斜杠以及网络掩码的二进制表示法中“1”的位数（即网络号中和网络掩码相关的是哪些位）。例如，192.0.2.96/28表示的是一个前28位被用作网络号的IP地址（和255.255.255.240的意思一样）。
子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的“与”运算（AND）即得出网络地址来。这样在路由器处理到来的分组时就可以采用同样的方法。
无类别域间路由 无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。
一个IP地址包含两部分：标识网络的前缀和紧接着的在这个网络内的主机地址。在之前的分类网络中，IP地址的分配把IP地址的32位按每8位为一段分开。这使得前缀必须为8，16或者24位。因此，可分配的最小的地址块有256（24位前缀，8位主机地址，28=256）个地址，而这对大多数企业来说太少了。大一点的地址块包含65536（16位前缀，16位主机，216=65536）个地址，而这对大公司来说都太多了。这导致不能充分使用IP地址并且在路由器上路由也很不便，因为大量的需要单独路由的小型网络（C类网络）在地域上分得很开很难进行聚合路由，这给路由设备增加了很多负担。
无类别域间路由是基于可变长子网掩码（VLSM）来进行任意长度的前缀的分配的。在RFC 950（1985）中有关于可变长子网掩码的说明。CIDR包括：
指定任意长度的前缀的可变长子网掩码技术。遵从CIDR规则的地址有一个后缀说明前缀的位数，例如：192.168.0.0/16。这使得对日益缺乏的IPv4地址的使用更加有效。将多个连续的前缀聚合成超网，以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。聚合使得互联网的路由表不用分为多级，并通过VLSM逆转“划分子网”的过程。根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理IP地址的分配的过程。因为在IPv6中也使用了IPv4的用后缀指示前缀长度的CIDR，所以IPv4中的分类在IPv6中已不再使用。
子网掩码的计算 怎么划分子网网段？为什么要遮掩IP地址？怎么个遮掩法？现在我们有这么个IP地址：
192.168.1.129
我们并不知道它的网络号，也不知道它属于哪部分子网网段。我们现在就需要一个东西来划分出子网网段，这个东西就叫：子网掩码。 再，我们给出具体子网掩码：255.255.255.0 什么要这么给？因为子网掩码的长度要和IP地址相同32位，每8位预先被划分为一段。255的二进制就是1111 1111。 那么我们把子网掩码设置为255.255.255.193 行不行？
这需要看它的二进制，子网掩码还需要满足一个条件才可以使用：它的二进制中1和0必须是连续的。
255.255.255.193的二进制：1111 1111.1111 1111.1111 1111.1100 0001可以看出它1并不连续，所以255.255.255.193不能作为子网掩码使用。255.255.255.0就很符合条件。那子网掩码怎么用？
用乘法来遮掩IP地址。1×1=1、1×0=0、0×0=0、0×1=0IP地址：192.168.1.129 ， 二进制：1100 0000.1010 1000.0000 0001.1000 0001 子网掩码：255.255.255.0 二进制：1111 1111.1111 1111.1111 1111.0000 0000计算：
1100 0000.1010 1000.0000 0001.1011 1100 1111 1111.1111 1111.1111 1111.1110 0000 ———————————————————— 1100 0000.1010 1000.0000 0001.1010 0000 不再是24位未被遮掩了，而是27位未被遮掩。被遮掩的后5位，我们不必再关心它是1还是0了。 这就意味着：后5位不论怎么变换，都是在同一个网段里。后5位的变化是在1100 0000.1010 000.0000 0001.</description>
    </item>
    
    <item>
      <title>TCP协议</title>
      <link>https://hzren.github.io/blog/2020-08-14-tcp%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 14 Aug 2020 14:46:06 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-14-tcp%E5%8D%8F%E8%AE%AE/</guid>
      <description>传输控制协议（缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在计算机网络OSI模型中，它处于第四层传输层，同用户数据报协议（UDP）位于同一层。
应用层向TCP层发送用于网络间传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（通常受链接数据链路层的最大传输单元（MTU）限制）。之后TCP把结果包传给IP层，由它来透过网络将包传送给接收端实体的TCP层。
TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认信息（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失并进行重传。TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和。
概念 数据在TCP层称为流（Stream），数据分组称为分段（Segment）。作为比较，数据在IP层称为Datagram，数据分组称为分片（Fragment）。 UDP 中分组称为Message。
运行方式 一个完整的TCP链接分为三个阶段：连接建立(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。操作系统将TCP连接抽象为套接字表示的本地端点（local end-point）作为编程接口给程序使用。在TCP链接的生命期周期内，本地端点会经历一系列的状态改变。
数据包结构 链接建立 TCP协议经过三次握手建立链接:
1. 客户端通过向服务器端发送一个SYN来建立一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数A。2. 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。3. 最后，客户端再发送一个ACK。此时包的序号被设定为A+1，而ACK的确认码则为B+1。当服务端收到这个ACK的时候，就完成了三次握手，并进入了连接建立状态。在第二步，服务器确认自己能收到客户端的数据包 在第三步，客户端收到服务器端的数据包，客户端确认服务器能收到自己的数据包，自己也能收到服务器的数据包 服务器端还不确定客户端是否能收到自己发送的数据包，所以服务器一定要等收到客户端发来的第二个ACK应答才真正建立链接 如果服务器端在收到了客户端的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接就处于一个中间状态，既没有成功，也没有失败。这个时候,服务器端会在一定时间内重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，服务器端才会断开这个连接。可以使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow在检查到 backlog 队列已满时，直接发 RST 包给客户端终止此连接,此时客户端程序会收到 104 Connection reset by peer 错误。
TCP_FASTOPEN 控制server socket 接收链接。
TCP_FASTOPEN_CONNECT 控制socket发起链接。
为什么是三次握手？
三次以上的握手是没意义的，因为没办法给每个对方发来的数据包都做确认，这样就陷入了确认包的死循环当中。三次握手的 三次握手的核心是通讯双方都明确自身能收到对方发来的数据包，对方能收到自己发来的数据包
绑定端口 主机在收到一个TCP包时，使用两端的IP地址与端口号来标识这个TCP包属于哪个TCP链接。主机使用一张表来存储所有的session，表中的每条称作Transmission Control Block（TCB），tcb结构上包括链接的源端口、源IP，目的端口、目的ip、序号、应答序号、对方窗口大小、己方窗口大小、tcp状态、tcp输入/输出队列、应用层输出队列、tcp的重传变量等。
服务器端的链接数量是无限的，只受内存的限制。客户端的连接数量，在Linux kernel 4.2 之前由于在发送第一个SYN到服务器之前需要先分配一个随机空闲的端口，理论上最大链接数受限于端口数据量，最大65k。从Linux 4.</description>
    </item>
    
    <item>
      <title>计算机网络 - 网络层</title>
      <link>https://hzren.github.io/blog/2020-08-11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</link>
      <pubDate>Tue, 11 Aug 2020 15:21:57 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</guid>
      <description>概念 网络层（Network Layer）是OSI模型中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两終端系統能够互连且決定最佳路径，並具有一定的拥塞控制和流量控制的能力。相当于传送邮件时需要地址一般重要。由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。
功能 寻址 对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信（类似于数据链路层的MAC地址），详细的编址方案参见IPv4和IPv6。
路由 在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。
常见网络层协议 IP （V4、V6）IPXX.25RARPICMP（V4、V6）IGMPIPsecRIPOSPF总结 网络层已经基本脱离了硬件层面，基本上全部属于软件层面定义的东西。IP协议虽然和IPX， IPSec，ICPMP协议位于同一层，但是它们基本都依赖于IP地址，ICMP，IGMP的报文都是通过IP报文进行传输的， IP协议是整个互联网事实上的基石。</description>
    </item>
    
    <item>
      <title>计算机网络 - 物理层</title>
      <link>https://hzren.github.io/blog/2020-08-10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</link>
      <pubDate>Mon, 10 Aug 2020 18:59:45 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</guid>
      <description>物理层的基本概念 物理层的主要任务描述为确定与传输媒体的接口的一些特性 机械特性 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。 电气特性 指明在接口电缆的各条线上出现的电压的范围。 功能特性 指明某条线上出现的某一电平的电压表示何种意义。 过程特性 指明对于不同功能的各种可能事件的出现顺序。 物理层基本工作内容 物理层利用传输介质为通信的两端建立、管理和释放物理链接，实现比特流的透明传输，保证比特流正确的传输到对端。物理层中承载的是比特流单位是比特（bit）。
物理层都有那些协议 电话网络modems-V.92 EIARS-232，EIA-422，EIA-423，RS-449，RS-485 Ethernet physical layerIncluding10BASE-T，10BASE2，10BASE5，100BASE-TX，100BASE-FX。100BASE-T，1000BASE-T，1000BASE-SX还有其他类型 Varieties of 802.11Wi-Fi物理层 DSL ISDN T1 and otherT-carrierlinks， and E1 and otherE-carrierlinks SONET/SDH Optical Transport Network（OTN） GSMUm air interface物理层 Bluetooth物理层 IEEE 1394 interface TransferJet物理层 Etherloop ARINC 818航空电子数字视频总线 G.hn/G.9960物理层 N bus（controller area network）物理层 理层协议就分为两类，点对点通信线路物理层协议和广播通信线路物理层协议，其中广播通信线路又分为有线通信线路和无线通信线路，有线通信线路就是咱们常说的网线形式的网络，无线通信线路就是WIFI。有线通讯不容易窃听,无线通讯的数据很容易被窃听到，以无线通讯的报文基本上都是需要在底层链路做加密的。
数据通信的基础知识 数据通信系统的模型 据传输按照使用的信道数量可以分为串行通信和并行通信
串行通信：将一个字符的二进制代码按从低位到高位顺序传输，传输中需要建立一个信道。 并行通信：将一个字符的二进制代码同时通过8条信道同时传输，每发送一个字符都需要建立8条信道，成本较高。 有关信道的几个基本概念 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 几种最基本的调制方法
调幅(AM)：载波的振幅随基带数字信号而变化。 调频(FM)：载波的频率随基带数字信号而变化。 调相(PM) ：载波的初始相位随基带数字信号而变化。 物理层下面的传输媒体 导向传输媒体
双绞线 屏蔽双绞线 STP (Shielded Twisted Pair) 无屏蔽双绞线 UTP (Unshielded Twisted Pair) 同轴电缆 50 Ω同轴电缆 75 Ω 同轴电缆 光缆 光纤的工作原理 光线在纤芯中传输的方式是不断地全反射 非导向传输媒体</description>
    </item>
    
    <item>
      <title>计算机网络中常见中间设备名称及功能</title>
      <link>https://hzren.github.io/blog/2020-08-06-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%8F%8A%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 06 Aug 2020 17:12:51 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-08-06-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%8F%8A%E5%8A%9F%E8%83%BD/</guid>
      <description>集线器/HUB: 集线器（Ethernet hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的装置。集线器是运作在OSI模型中的实体层，可以让其连结的设备工作在同一网段。集线器上有多个I/O端口，信号从任意一个端口进入后，会从其他端口出现。中继器（Repeater hub，集线器的一种）也会参与冲突检测（collision detection），在检测到冲突时向所有端口转发拥塞信号。
集线器相比于交换机更为简单，它可以被视作有多个端口的中继器，从一个端口接受比特位（或符号），再从其他端口送出。它对物理层数据包有所感知，可以检测到其开始、挂起及冲突。在检测到冲突时会发送拥塞信号以传播这一事件。集线器不能对经过它的网络流量做更进一步地检查与管理：任何进入的数据包都会被广播到其他端口。集线器/中继器无法储存数据——数据包必须在接收时被发送，一旦发生冲突，就会丢包（发送端应当能够侦测到，并重新发送）。基于此，集线器只能以半双工模式工作。因此，由于冲突域更广，相比于使用更复杂的网络设备，使用集线器的数据网络更容易出现数据包冲突。
以太网设计目标：电脑使用一个网络接口，可以同时与多台电脑通信，将电脑连接起来的黑盒子最先面世，称之为集线器，但我们更喜欢叫它Hub。 这种集线器，通常有多个端口，可以接入多台电脑，这种黑盒子使电脑连接在一起成为一种可能，其内部工作原理，就是信号放大器。
HUB内部采用广播的形式传播其收到的每一个网络包.因为其采用广播的形式, 这就注定了一个HUB上不可能有太多端口, 不能链接太多电脑, 不然在广播网络时就形成了网络风暴。
由于HUB只是简单的转发，所以hub工作在物理层（L1）。
网桥: 网桥将网络的多个网段在数据链路层（OSI模型第2层）连接起来（即桥接）。
网桥有别于路由器。路由器允许多个网络之间的独立通信，但又保持区隔，而网桥则是将两个独立的网络连接起来，就如同单一网络。如果所桥接的网络有一个以上的区段是无线网络，则该设备称为无线网桥。
桥接器在功能上与集线器等其他用于连接网段的设备类似，不过后者工作在物理层（OSI模型第1层）。
网桥能够识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的数据帧转发给相连的另一个网段（network segment）。由于能够对数据帧拆包、暂存、重新打包（称为存储转发机制store-and-forward），网桥能够连接不同技术参数传输速率的数据链路，如连接10BASE-T与100BASE-TX。
数据帧中有一个位叫做FCS，用来通过CRC方式校验数据帧中的位。网桥可以检查FCS，将那些损坏的数据帧丢弃。
网桥在向其他网段转发数据帧时会做冲突检测控制。
网桥还能通过地址自学机制和过滤功能控制网络流量，具有OSI第2层网络交换机功能。其机制是网桥内部有一个数据库，最初没有数据。当网桥从一个网段收到一个数据帧，就会在数据库中登记（或者更新）数据帧的源地址属于这个网段，并检查数据包的目的地址。如果目的地址在数据库中属于另外一个网段，则网桥向该网段转发该数据帧；如果目的地址在数据库中没有记录，则网桥向除了源地址所在之外的其他所有网段转发（flood）该数据帧。
桥接器仅仅在不同网络之间有数据传输的时候才将数据转发到其他网络，不是像集线器那样对所有数据都进行广播。对于以太网，“桥接”这一术语正式的含义是指符合IEEE802.1D标准的设备，即“网络切换”。网桥可以分割网段，不似集线器仍是在为同一碰撞域，所以对频宽耗损较大。因网桥透过其内之MAC表格，让传送帧不会通过，所以其称之为数据连接层操作之网络元件，可隔离碰撞。
交换机: 在集线器的基础上，添加了MAC地址学习功能，成为了交换机，这样可以避免集线器对所有帧都广播的弊病。
交换机是一种多端口的网桥，在数据链路层使用MAC地址转发数据。通过引入路由功能，一些交换机也可以在网络层转发数据，这种交换机一般被称为三层交换机或者多层交换机。
工作原理 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。
交换机对数据包的转发是建立在MAC地址——物理地址基础之上的，对于IP网络协议来说，它是透明的，即交换机在转发数据包时，不知道也无须知道信源机和信宿机的IP地址，只需知其物理地址。
交换机在操作过程当中会不断的收集资料去建立它本身的一个地址表，这个表相当简单，它说明了某个MAC地址是在哪个端口上被发现的，所以当交换机收到一个TCP/ IP封包时，它便会查看该数据包的目的MAC地址，核对自己的地址表以确认应该从哪个端口把数据包发出去。由于这个过程比较简单，加上这功能由一崭新硬件进行——ASIC，因此速度相当快。一般只需几十微秒，交换机便可决定一个IP封包该往哪里送。
如果目的地MAC地址不能在地址表中找到时，交换机会把IP封包「扩散」出去，即把它从每一个端口中送出去，就如交换机在处理一个收到的广播封包时一样。二层交换机的弱点正是它处理广播封包的手法不太有效，比方说，当一个交换机收到一个从TCP / IP工作站上发出来的广播封包时，他便会把该封包传到所有其他端口去，哪怕有些端口上连的是IPX或DECnet工作站。这样一来，非TCP/ IP节点的带宽便会受到负面的影响，就算同样的TCP/ IP节点，如果他们的子网跟发送那个广播封包的工作站的子网相同，那幺他们也会无缘无故地收到一些与他们毫不相干的网络广播，整个网络的效率因此会大打折扣。
工作方式 当一台交换机安装配置好之后，其工作过程如下：
收到某网段（设为A）MAC地址为X的计算机发给MAC地址为Y的计算机的数据包。交换机从而记* 下了MAC地址X在网段A。这称为学习（learning）。 交换机还不知道MAC地址Y在哪个网段上，于是向除了A以外的所有网段转发该数据包。这称为泛洪（flooding）。 MAC地址Y的计算机收到该数据包，向MAC地址X发出确认包。交换机收到该包后，从而记录下MAC地址Y所在的网段。 交换机向MAC地址X转发确认包。这称为转发（forwarding）。 交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包。这称为过滤（filtering）。 交换机内部的MAC地址-网段查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。 对于全交换（full-switch）局域网，交换机每个端口只连接一台设备，因此不会发生碰撞。交换机也不需要做过滤。 但这些设备依然都是桥接设备，因为帧经过它们时，帧原封不动。
但是随着无线局域网的诞生，关于桥接的定义被刷新，有线的Ethernet II 帧访问无线802.11时，帧格式发生了变化，但依然称AP（Access Point)为桥接设备，为何？因为一个广播帧可以无障碍通过AP，AP并没有分割广播域，所以依然是桥接设备。
路由器 路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定封包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的封包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）
基本概念 由器就是连接两个以上个别网络的设备。
由于位于两个或更多个网络的交汇处，从而可在它们之间传递分组（一种数据的组织形式）。路由器与交换机在概念上有一定重叠但也有不同：交换机泛指工作于任何网络层次的数据中继设备（尽管多指网桥），而路由器则更专注于网络层。
路由器与交换机的差别，路由器是属于OSI第三层的产品，交换机是OSI第二层的产品。第二层的产品功能在于，将网络上各个电脑的MAC位址记在MAC地址表中，当区域网路中的电脑要经过交换机去交换传递数据时，就查询交换机上的MAC地址表中的信息，将封包传送给指定的电脑，而不会像第一层的产品（如集线器）每台在网络中的电脑都发送。而路由器除了有交换机的功能外，更拥有路由表作为传送封包时的依据，在有多种选择的路径中选择最佳的路径。此外，并可以连接两个以上不同网段的网络，而交换机只能连接两个。并具有IP分享的功能，如：区分哪些封包是要传送至WAN。路由表存储了（向前往）某一网络的最佳路径，该路径的“路由度量值”以及下一个（跳路由器）。参考条目路由获得这个过程的详细描述。
尽管也有其它一些很少用到的被路由协议，但路由通常指的就是IP路由。</description>
    </item>
    
    <item>
      <title>计算机网络 - 数据链路层</title>
      <link>https://hzren.github.io/blog/2020-07-23-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
      <pubDate>Thu, 23 Jul 2020 16:01:00 +0800</pubDate>
      <author>hzren@outlook.com (renhongzhen)</author>
      <guid>https://hzren.github.io/blog/2020-07-23-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
      <description>概念 数据链路层（Data Link Layer）是OSI参考模型第二层，位于物理层与网络层之间。在广播式多路访问链路中（局域网），由于可能存在介质争用，它还可以细分成介质访问控制（MAC）子层和逻辑链路控制（LLC）子层，介质访问控制（MAC）子层专职处理介质访问的争用与冲突问题。
只提供导线的一端到另一端的数据传输。
一个IP数据包的传输要经过多个数据链路层的链接，数据链路层存在于两个物理链接(有线/无线)设备之间。代表设备： 普通交换机, 网卡, 桥接器
交换机根据需要发送的以太网帧的目标mac地址， 找到对应的物理端口，从该端口将该帧发送出去
主要功能 概要 在两个网络实体之间提供数据链路连接的建立、维持和释放管理。构成数据链路数据单元（frame：数据帧），并对帧定界、同步、收发顺序的控制。传输过程中的网路流量控制、差错检测和差错控制等方面。
数据链路层会在 frame 尾端置放检查码（parity，sum，CRC）以检查实质内容，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，并对物理层的原始数据进行数据封装。 数据链路层中的数据封装是指：封装的数据信息中，包含了地址段和数据段等。地址段含有点对点发送节点和接收节点的地址（如MAC），控制段用来表示数格连接帧的类型，数据段包含实际要传输的数据。
详情 四个基本功能：
1. 链路管理
数据链路层有三种基本服务。无确认的无连接服务，有确认的无连接服务，有确认的有连接服务。链路管理主要是负责链路的建立，维护和释放。主要面向有连接的服务。
2. 帧同步
接收方收到的比特流中，一帧的开始位置与结束位置。
3. 差错控制
用于使接收方确认接受到的就是发送方发送的数据。
4. 透明传输
就是不管数据是怎样的比特组合，都能在链路上传输。
数据链路层是不可靠的。 现在互联网的数据链路层协议使用的最多的就是PPP和CSMA/CD协议(用于拨号和以太网)。这两种协议都不需要序号和确认机制，当接收方检测到帧在传输中出了差错后，或者默默丢弃不做处理(PPP或者CSMA/CD)，或者使用重传机制要求发送方重传(HDLC)，后面的情况很少用。因此。如果需要可靠传输，就需要由高层的TCP负责重传，但是数据链路层并不知道这是重传的帧，所以还是默认可靠传输由传输层负责，而不是数据链路层。
当数据链路层使用PPP或者CSMA/CD协议时，在数据链路层的接收端对所接受的帧进行差错检测是为了不将已经发现出错的帧接收下来。如果不进行检测，那么接收方上交给主机的帧。可能就包括传输过程中，已经出了错的帧。而这种帧对于接收方的主机，是没有用的。所以，接收方进行差错检测，是为了&amp;quot;上交给主机的帧，都是没有传输差错的&amp;quot;，有差错的帧都丢弃了。达到一定的概率之后，我们就可以以接近1的概率去说，凡是上交给主机的帧，都是没有传输差错的。
数据链路层没有流量控制，处理不过来，接受到的包出错会被直接丢掉。
总体来说，网线比无线可靠，但网线也不是100%可靠，在交换机的入端口错误统计上，CRC Error 一般都是名列前茅，造成CRC Error 的原因有：网卡的软件故障、硬件故障、网线质量、信号干扰。曾经在数据中心里，接入层的交换机某些入口有1.5%% 的CRC Error，先换网线，情况依然。到最后把服务器重启，CRC Error 消失，过几天故障依然。后来发现这种情况只发生在某个型号，特定版本的服务器上，解决方案是升级软件版本，故障消失。无线是很不可靠的，可以在电脑上ping 无线路由器，ping 100个包，一般都会丢几个。造成丢失的原因：因为周围有很多工作在同一个频端的无线路由器，互相会干扰，造成无线信号不可用，从而丢弃。还有一个原因，无线路由器与电脑之间有很多墙，信号衰减很多，再加上干扰，最后变得面目可憎而被抛弃。 ** 来自知乎 车小胖**
分帧 分帧是靠硬件完成的。 不同协议的数据帧格式可能不同。
以太网帧 在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址。帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议)。以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏。
结构 来自线路的二进制数据包称作一个帧。从物理线路上看到的帧，除其他信息外，还可看到前导码和帧开始符。任何物理硬件都会需要这些信息。 下面的表格显示了在以1500个八位元组为MTU传输(有些吉比特以太网甚至更高速以太网支持更大的帧，称作巨型帧)时的完整帧格式。一个八位元组是八个位组成的数据(也就是现代计算机的一个字节)。
**802.3 以太网帧结构 **
IEEE 802.1Q协议帧结构，相比802.3以太网帧多了 802.1Q标签
** IEEE 802.1ad协议帧结构 **
前导码和帧开始符
一个帧以7个字节的前导码和1个字节的帧开始符作为帧的开始。快速以太网之前，在线路上帧的这部分的位模式是10101010 10101010 10101010 10101010 10101010 10101010 10101010 10101011。由于在传输一个字节时最低位最先传输(LSB)，因此其相应的16进制表示为0x55 0x55 0x55 0x55 0x55 0x55 0x55 0xD5。</description>
    </item>
    
  </channel>
</rss>
